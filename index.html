<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üè∏ Badminton Annotation Tool</title>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .workspace {
            display: flex;
            width: min(90vw, 1100px);
            margin-left: auto;
            margin-right: auto;
            gap: 20px;
            align-items: flex-start;
        }

        .left-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .video-section {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
            position: sticky;
            top: 10px;
            z-index: 5;
            background: white;
            padding-bottom: 12px;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            width: 100%;
        }

        video {
            width: 100%;
            height: auto;
            display: block;
        }

        .video-info {
            background: #2c3e50;
            color: white;
            padding: 10px;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 0 0 4px 4px;
        }

        .video-info-left {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .frame-controls {
            display: flex;
            gap: 10px;
            font-size: 11px;
        }

        .frame-controls span {
            background: #34495e;
            padding: 4px 8px;
            border-radius: 3px;
        }

        /* Custom Video Controls */
        .court-video-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: #2c3e50;
            border-radius: 0 0 8px 8px;
            margin-top: -4px;
        }

        .court-video-controls .ctrl-btn {
            background: #3498db;
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: background 0.2s;
        }

        .court-video-controls .ctrl-btn:hover {
            background: #2980b9;
        }

        .court-video-controls .video-seek {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #4a5568;
            border-radius: 3px;
            cursor: pointer;
        }

        .court-video-controls .video-seek::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
        }

        .court-video-controls .video-seek::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .court-video-controls .time-display {
            color: #ecf0f1;
            font-size: 12px;
            font-family: monospace;
            min-width: 90px;
        }

        .court-video-controls .speed-select {
            background: #34495e;
            color: #ecf0f1;
            border: 1px solid #4a5568;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        .court-video-controls .fullscreen-btn {
            margin-left: auto;
        }

        /* Shot Tags Overlay */
        /* Shot Toast - Brief notification for each shot */
        .shot-toast {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            text-align: left;
            min-width: 120px;
        }

        .shot-toast.visible {
            opacity: 1;
        }

        .shot-toast .toast-shot-num {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 4px;
        }

        .shot-toast .toast-shot-name {
            font-size: 20px;
        }

        /* Court Combo Indicator (shows typed combo for shot override) */
        .court-combo-indicator {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(46, 204, 113, 0.95);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            text-align: center;
            font-family: monospace;
        }

        .court-combo-indicator.visible {
            opacity: 1;
        }

        .court-combo-indicator.pending {
            background: rgba(241, 196, 15, 0.95);
        }

        .court-combo-indicator.matched {
            background: rgba(46, 204, 113, 0.95);
        }

        .court-combo-indicator.error {
            background: rgba(231, 76, 60, 0.95);
        }

        .court-combo-indicator .combo-keys {
            font-size: 18px;
            letter-spacing: 2px;
        }

        .court-combo-indicator .combo-shot {
            font-size: 12px;
            opacity: 0.9;
            margin-top: 4px;
        }

        .info-panel {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .right-panel {
            width: 320px;
            max-width: 30%;
            position: sticky;
            top: 10px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            background: #fbfbfb;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.08);
            padding: 12px;
        }

        .right-panel .annotations-log {
            max-height: none;
        }

        .annotations-tags h3 {
            font-size: 15px;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .tags-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .tag-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-radius: 6px;
            border-left: 4px solid #3498db;
            background: #ffffff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
        }

        .tag-item:hover {
            background: #f0f8ff;
            transform: translateY(-1px);
        }

        .tag-item.active {
            border-left-color: #27ae60;
            background: #e8f5e9;
        }

        .tag-shot {
            font-size: 12px;
            font-weight: 600;
            color: #2c3e50;
        }

        .tag-cross {
            font-size: 10px;
            color: #e74c3c;
            margin-left: 6px;
            font-weight: 700;
        }

        .tag-delete {
            background: none;
            border: none;
            color: #c0392b;
            font-size: 14px;
            cursor: pointer;
        }

        .tag-delete:hover {
            color: #922b21;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-info {
            background: #3498db;
            color: white;
        }

        .btn-info:hover {
            background: #2980b9;
        }

        .file-input-wrapper {
            margin-bottom: 15px;
        }

        .file-input-wrapper input[type="file"] {
            padding: 8px;
            border: 2px dashed #3498db;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }

        .annotations-log {
            background: #f8f9fa;
            border-radius: 4px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .annotations-log h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }

        .annotations-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .annotations-table th,
        .annotations-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .cross-indicator {
            background: #e74c3c;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 5px;
        }

        .annotations-table th {
            background: #34495e;
            color: white;
            position: sticky;
            top: 0;
        }

        .annotations-table tr:hover {
            background: #f0f0f0;
        }

        .annotations-table tr {
            cursor: pointer;
        }

        .delete-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }

        .delete-btn:hover {
            background: #c0392b;
        }

        .empty-state {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
            font-style: italic;
        }

        .stats {
            display: flex;
            gap: 12px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #555;
            flex-wrap: wrap;
        }

        .stats span {
            background: #ecf0f1;
            padding: 8px 12px;
            border-radius: 4px;
        }

        .stats span strong {
            font-weight: 700;
        }

        .frame-search-row form {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .frame-search-row label {
            font-weight: 600;
            font-size: 12px;
            color: #2c3e50;
        }

        .frame-search-row input {
            width: 120px;
            padding: 6px 8px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 13px;
        }

        .nav-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .import-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .import-controls label {
            font-weight: 600;
            font-size: 12px;
            color: #2c3e50;
        }

        .import-controls input[type="file"] {
            padding: 6px;
            border: 1px dashed #95a5a6;
            border-radius: 4px;
            background: #fff;
        }

        .fps-form {
            display: flex;
            gap: 6px;
            align-items: center;
            font-size: 12px;
        }

        .fps-form input {
            width: 80px;
            padding: 4px 6px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 12px;
        }

        .fps-form button {
            padding: 4px 10px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            background: #34495e;
            color: white;
        }

        .fps-form button:hover {
            background: #2c3e50;
        }

        .btn-secondary {
            background: #7f8c8d;
            color: white;
        }

        .btn-secondary:hover {
            background: #6c7a7c;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        #comboDisplay.status-pending {
            color: #2980b9;
        }

        #comboDisplay.status-error {
            color: #e74c3c;
        }

        #comboDisplay.status-success {
            color: #27ae60;
        }

        #comboDisplay.status-default {
            color: #555;
        }

        .quick-access {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .quick-group {
            background: #f0f4f7;
            border-radius: 6px;
            padding: 10px;
            flex: 1;
            min-width: 240px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.08);
        }

        .quick-title {
            font-weight: 700;
            font-size: 12px;
            letter-spacing: 0.03em;
            text-transform: uppercase;
            color: #2c3e50;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .quick-count {
            font-size: 10px;
            font-weight: 600;
            color: #7f8c8d;
        }

        .quick-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .quick-button {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.1);
            background: white;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .quick-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.18);
            border-color: #3498db;
        }

        .quick-button .quick-shot {
            font-size: 11px;
        }

        .quick-button .quick-shortcut {
            font-family: monospace;
            font-size: 10px;
            background: #ecf0f1;
            padding: 2px 4px;
            border-radius: 3px;
            color: #2c3e50;
        }

        .quick-count-pill {
            background: rgba(44, 62, 80, 0.85);
            color: white;
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 10px;
        }

        /* Search panel */
        .toggle-search {
            position: fixed;
            bottom: 120px;
            right: 20px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-search:hover {
            background: #229954;
        }

        .search-bar {
            position: fixed;
            bottom: 120px;
            right: 70px;
            z-index: 10000;
            display: none;
        }

        .search-bar.show {
            display: block;
        }

        .search-input {
            width: 280px;
            padding: 10px 14px;
            border: 2px solid #3498db;
            border-radius: 6px 6px 0 0;
            font-size: 13px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .search-results {
            background: white;
            border: 2px solid #3498db;
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 260px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .search-result-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #ecf0f1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .search-result-item:hover {
            background: #f8f9fa;
        }

        .search-result-item .shot-name {
            font-weight: 600;
        }

        .search-result-item .shot-key {
            background: #3498db;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
        }

        /* Toggle visual keyboard button */
        .toggle-visual-keyboard {
            position: fixed;
            bottom: 170px;
            right: 20px;
            background: #9b59b6;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-visual-keyboard:hover {
            background: #8e44ad;
        }

        .shot-button.highlight-key {
            transform: scale(1.08);
            box-shadow: 0 6px 14px rgba(52, 152, 219, 0.35);
            border-width: 3px;
        }

        .quick-empty {
            color: #95a5a6;
            font-size: 11px;
            font-style: italic;
        }

        /* Toast notification for annotations */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #2c3e50;
            color: white;
            padding: 15px 20px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10000;
            font-size: 14px;
            font-weight: 600;
            display: none;
            animation: slideIn 0.3s ease-out;
        }

        .toast.show {
            display: block;
        }

        .toast.cross {
            background: #e74c3c;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Keyboard legend */
        .keyboard-legend {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            max-width: 400px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 9999;
            font-size: 11px;
            display: none;
        }

        .keyboard-legend.show {
            display: block;
        }

        .keyboard-legend h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 13px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .legend-category {
            margin-bottom: 10px;
        }

        .legend-category-title {
            font-weight: 600;
            color: #34495e;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            font-size: 10px;
        }

        .legend-key {
            background: #ecf0f1;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
            font-family: monospace;
            min-width: 20px;
            text-align: center;
        }

        .toggle-legend {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-legend:hover {
            background: #2980b9;
        }

        /* Last annotation indicator */
        .last-annotation {
            background: #27ae60;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            display: none;
        }

        .last-annotation.show {
            display: block;
        }

        /* Info Modal */
        .info-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            overflow: auto;
        }

        .info-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .info-modal-content {
            background-color: white;
            margin: auto;
            padding: 30px;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .info-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .info-modal-header h2 {
            margin: 0;
            color: #2c3e50;
        }

        .info-modal-close {
            background: none;
            border: none;
            font-size: 28px;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .info-modal-close:hover {
            color: #333;
        }

        .info-section {
            margin-bottom: 20px;
        }

        .info-section h3 {
            color: #34495e;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #ecf0f1;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-label {
            font-weight: 600;
            color: #555;
        }

        .info-value {
            color: #2c3e50;
        }

        .label-stats {
            max-height: 300px;
            overflow-y: auto;
        }

        .label-stat-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #ecf0f1;
        }

        .label-stat-item:last-child {
            border-bottom: none;
        }

        .label-name {
            font-weight: 500;
            color: #34495e;
        }

        .label-count {
            background: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        /* Court Help Modal Styles */
        .court-help-body {
            padding: 10px 0;
        }

        .help-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .help-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .help-section h3 {
            color: #2c3e50;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .help-section ol {
            margin: 0;
            padding-left: 20px;
        }

        .help-section ol li {
            margin-bottom: 6px;
            font-size: 13px;
            color: #555;
        }

        .help-shortcuts-table {
            width: 100%;
            border-collapse: collapse;
        }

        .help-shortcuts-table td {
            padding: 6px 10px;
            font-size: 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .help-shortcuts-table td:first-child {
            width: 100px;
            text-align: center;
        }

        .help-shortcuts-table kbd {
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 11px;
        }

        .help-zones-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .help-zone {
            background: #f0f4f8;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #555;
        }

        .help-zone span {
            display: inline-block;
            width: 20px;
            height: 20px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            margin-right: 6px;
            font-weight: bold;
            font-size: 11px;
        }

        /* Technical Labels Styles */
        .technical-labels-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 20px;
            max-height: 500px;
            overflow-y: auto;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .technical-label-item {
            background: #fff;
            border: 2px solid #e74c3c;
            border-radius: 4px;
            padding: 8px 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .technical-label-item:hover {
            background: #e74c3c;
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(231, 76, 60, 0.3);
        }

        .technical-label-abbr {
            font-weight: 700;
            font-size: 14px;
            color: #e74c3c;
        }

        .technical-label-item:hover .technical-label-abbr {
            color: white;
        }

        .technical-label-desc {
            font-size: 10px;
            color: #666;
            line-height: 1.2;
        }

        .technical-label-item:hover .technical-label-desc {
            color: rgba(255, 255, 255, 0.9);
        }

        .tagged-technical-section {
            margin-top: 20px;
            border-top: 2px solid #e74c3c;
            padding-top: 15px;
        }

        .tagged-technical-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 10px;
            background: #fff5f5;
            border-radius: 6px;
            margin-bottom: 10px;
            transition: background 0.2s;
        }

        .tagged-technical-header:hover {
            background: #ffe0e0;
        }

        .tagged-technical-header h4 {
            margin: 0;
            color: #e74c3c;
            font-size: 16px;
        }

        .toggle-icon {
            font-size: 14px;
            color: #e74c3c;
            transition: transform 0.2s;
        }

        .tagged-technical-header.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .tagged-technical-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .tagged-technical-item {
            background: #fff;
            border-left: 4px solid #e74c3c;
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tagged-technical-item:hover {
            background: #fff5f5;
            transform: translateX(4px);
        }

        .tagged-technical-item.editing {
            background: #fff3cd;
            border-left-color: #ffc107;
        }

        .tagged-technical-info {
            flex: 1;
        }

        .tagged-technical-label {
            font-weight: 700;
            color: #e74c3c;
            font-size: 16px;
            margin-right: 8px;
        }

        .tagged-technical-meta {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        .tagged-technical-actions {
            display: flex;
            gap: 8px;
        }

        .tagged-technical-actions button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .tagged-technical-edit-btn {
            background: #3498db;
            color: white;
        }

        .tagged-technical-edit-btn:hover {
            background: #2980b9;
        }

        .tagged-technical-delete-btn {
            background: #e74c3c;
            color: white;
        }

        .tagged-technical-delete-btn:hover {
            background: #c0392b;
        }

        .tagged-technical-cancel-btn {
            background: #95a5a6;
            color: white;
        }

        .tagged-technical-cancel-btn:hover {
            background: #7f8c8d;
        }

        /* ========== COURT POSITION MODE STYLES ========== */
        
        .mode-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .mode-btn {
            padding: 8px 16px;
            border: 2px solid #bdc3c7;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.2s;
        }

        .mode-btn:hover {
            border-color: #3498db;
            background: #ebf5fb;
        }

        .mode-btn.active {
            border-color: #3498db;
            background: #3498db;
            color: white;
        }

        .court-mode-container {
            display: none;
        }

        .court-mode-container.active {
            display: block;
        }

        .court-workspace {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 15px;
            align-items: start;
            max-width: 1600px;
            margin: 0 auto;
        }

        .court-left-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .court-center-panel {
            display: none; /* Hidden - court map moved to collapsible */
        }

        .court-right-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        /* Compact Shot Info Bar */
        .compact-shot-bar {
            display: flex;
            align-items: center;
            gap: 15px;
            background: #2c3e50;
            color: white;
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 13px;
            flex-wrap: wrap;
        }

        .compact-shot-bar .shot-segment {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .compact-shot-bar .segment-label {
            opacity: 0.7;
            font-size: 11px;
            text-transform: uppercase;
        }

        .compact-shot-bar .segment-value {
            background: rgba(255,255,255,0.15);
            padding: 3px 10px;
            border-radius: 4px;
            font-weight: 500;
        }

        .compact-shot-bar .segment-value.pending {
            opacity: 0.5;
        }

        .compact-shot-bar .traj-buttons {
            display: flex;
            gap: 4px;
        }

        .compact-shot-bar .traj-btn {
            width: 28px;
            height: 28px;
            border: 1px solid rgba(255,255,255,0.3);
            background: transparent;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .compact-shot-bar .traj-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .compact-shot-bar .traj-btn.active {
            background: #e67e22;
            border-color: #e67e22;
        }

        .compact-shot-bar .shot-type-display {
            background: #27ae60;
            padding: 3px 10px;
            border-radius: 4px;
            font-weight: bold;
        }

        /* Collapsible Court Map */
        .court-map-collapsible {
            background: #f8f9fa;
            border-radius: 8px;
            overflow: hidden;
        }

        .court-map-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: #34495e;
            color: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }

        .court-map-toggle:hover {
            background: #2c3e50;
        }

        .court-map-toggle .toggle-icon {
            transition: transform 0.2s;
        }

        .court-map-collapsible.expanded .toggle-icon {
            transform: rotate(180deg);
        }

        .court-map-content {
            display: none;
            padding: 10px;
        }

        .court-map-collapsible.expanded .court-map-content {
            display: block;
        }

        .match-setup-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
        }

        .match-setup-panel h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #2c3e50;
        }

        .setup-row {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            align-items: center;
        }

        .setup-row label {
            font-weight: 600;
            font-size: 12px;
            color: #555;
            min-width: 30px;
        }

        .setup-row input[type="text"] {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 13px;
        }

        .setup-row select {
            padding: 6px 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 13px;
            background: white;
        }

        .score-display {
            background: #2c3e50;
            color: white;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .score-display .game-info {
            font-size: 12px;
            color: #bdc3c7;
            margin-bottom: 5px;
        }

        .score-display .score-main {
            font-size: 32px;
            font-weight: 700;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .score-display .player-score {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .score-display .player-name {
            font-size: 12px;
            color: #bdc3c7;
        }

        .score-display .score-num {
            font-size: 28px;
            font-weight: 700;
        }

        .score-display .score-num.serving {
            color: #f1c40f;
        }

        .score-display .vs {
            font-size: 18px;
            color: #7f8c8d;
        }

        .rally-info {
            font-size: 12px;
            color: #bdc3c7;
            margin-top: 8px;
        }

        .rally-control-panel {
            background: #fff;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 15px;
        }

        .rally-control-panel h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #2c3e50;
        }

        .rally-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .rally-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.2s;
        }

        .rally-btn.new-rally {
            background: #27ae60;
            color: white;
        }

        .rally-btn.new-rally:hover {
            background: #229954;
        }

        .rally-btn.p1-won {
            background: #3498db;
            color: white;
        }

        .rally-btn.p1-won:hover {
            background: #2980b9;
        }

        .rally-btn.p2-won {
            background: #9b59b6;
            color: white;
        }

        .rally-btn.p2-won:hover {
            background: #8e44ad;
        }

        .rally-btn.undo {
            background: #e74c3c;
            color: white;
        }

        .rally-btn.undo:hover {
            background: #c0392b;
        }

        .rally-btn.cancel {
            background: #95a5a6;
            color: white;
        }

        .rally-btn.cancel:hover {
            background: #7f8c8d;
        }

        .current-shot-display {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .current-shot-display h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #856404;
        }

        .shot-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 13px;
        }

        .shot-info .from-zone, .shot-info .to-zone {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .shot-info .zone-label {
            font-weight: 600;
            color: #555;
            min-width: 50px;
        }

        .shot-info .zone-value {
            background: #3498db;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-weight: 600;
        }

        .shot-info .zone-value.pending {
            background: #95a5a6;
        }

        .shot-info .shot-type {
            margin-top: 8px;
            padding: 8px;
            background: #d4edda;
            border-radius: 4px;
            font-weight: 600;
            color: #155724;
        }

        /* Court Map Styles */
        .court-map-container {
            background: #2c3e50;
            border-radius: 8px;
            padding: 20px;
            position: relative;
        }

        .court-map {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-width: 400px;
            margin: 0 auto;
        }

        .court-half {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .court-half.p2 {
            margin-bottom: 0;
        }

        .court-half.p1 {
            margin-top: 0;
        }

        .court-net {
            height: 8px;
            background: linear-gradient(90deg, #fff 0%, #fff 48%, #2c3e50 48%, #2c3e50 52%, #fff 52%, #fff 100%);
            margin: 8px 0;
            position: relative;
        }

        .court-net::after {
            content: 'NET';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: #2c3e50;
            color: #fff;
            padding: 2px 10px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 2px;
        }

        .court-row {
            display: flex;
            gap: 2px;
        }

        .court-zone {
            flex: 1;
            height: 50px;
            background: #27ae60;
            border: 2px solid #1e8449;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .court-zone:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .court-zone.service-zone {
            height: 35px;
            background: #f39c12;
            border-color: #d68910;
        }

        .court-zone.back-zone {
            height: 55px;
        }

        .court-zone.mid-zone {
            height: 50px;
        }

        .court-zone.front-zone {
            height: 45px;
        }

        .court-zone .zone-number {
            font-size: 16px;
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .court-zone .zone-name {
            font-size: 9px;
            color: rgba(255,255,255,0.9);
            text-align: center;
            line-height: 1.1;
        }

        .court-zone.selected-from {
            background: #3498db !important;
            border-color: #2980b9 !important;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.5);
        }

        .court-zone.valid-target {
            animation: pulse-target 1s infinite;
        }

        @keyframes pulse-target {
            0%, 100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); }
            50% { box-shadow: 0 0 0 8px rgba(46, 204, 113, 0); }
        }

        .court-zone.selected-to {
            background: #9b59b6 !important;
            border-color: #8e44ad !important;
        }

        .court-zone.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
        }

        .court-zone.highlight {
            background: #e74c3c !important;
            border-color: #c0392b !important;
        }

        .player-label {
            text-align: center;
            color: white;
            font-size: 12px;
            font-weight: 600;
            padding: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            margin-bottom: 5px;
        }

        .player-label.p1 {
            background: #3498db;
        }

        .player-label.p2 {
            background: #9b59b6;
        }

        /* Rally Log Styles */
        .rally-log-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .rally-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            position: sticky;
            top: 0;
            background: #f8f9fa;
            padding-bottom: 5px;
            z-index: 1;
        }

        .rally-log-header h3 {
            margin: 0;
            font-size: 14px;
            color: #2c3e50;
        }

        .rally-log-header select {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-size: 12px;
            background: white;
            cursor: pointer;
        }

        .rally-log-panel h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #2c3e50;
            position: sticky;
            top: 0;
            background: #f8f9fa;
            padding-bottom: 5px;
        }

        .rally-entry {
            background: white;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            border-left: 4px solid #3498db;
        }

        .rally-entry.current {
            border-left-color: #f1c40f;
            background: #fffbea;
        }

        .rally-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 600;
            color: #2c3e50;
        }

        .rally-winner {
            background: #27ae60;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
        }

        .rally-shots {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .rally-shot {
            font-size: 11px;
            color: #555;
            padding: 4px 8px;
            background: #f0f0f0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rally-shot .shot-num {
            font-weight: 700;
            color: #3498db;
            min-width: 20px;
        }

        .rally-shot .shot-player {
            font-weight: 600;
            color: #2c3e50;
        }

        .rally-shot .shot-zones {
            color: #7f8c8d;
        }

        .rally-shot .shot-type {
            color: #27ae60;
            font-weight: 600;
        }

        /* Server Selection Modal */
        .server-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .server-modal.show {
            display: flex;
        }

        .server-modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
        }

        .server-modal-content h3 {
            margin: 0 0 20px 0;
            color: #2c3e50;
        }

        .server-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .server-btn {
            padding: 20px 40px;
            border: 3px solid;
            border-radius: 12px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 700;
            transition: all 0.2s;
        }

        .server-btn.p1 {
            background: #ebf5fb;
            border-color: #3498db;
            color: #3498db;
        }

        .server-btn.p1:hover {
            background: #3498db;
            color: white;
        }

        .server-btn.p2 {
            background: #f5eef8;
            border-color: #9b59b6;
            color: #9b59b6;
        }

        .server-btn.p2:hover {
            background: #9b59b6;
            color: white;
        }

        .game-control-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
        }

        .game-control-panel h4 {
            margin: 0 0 10px 0;
            font-size: 13px;
            color: #2c3e50;
        }

        .game-buttons {
            display: flex;
            gap: 10px;
        }

        .game-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.2s;
        }

        .game-btn.end-game {
            background: #e74c3c;
            color: white;
        }

        .game-btn.end-game:hover {
            background: #c0392b;
        }

        .game-btn.new-game {
            background: #27ae60;
            color: white;
        }

        .game-btn.new-game:hover {
            background: #229954;
        }

        .court-export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        /* ========== CANVAS COURT MODE STYLES ========== */
        
        .canvas-mode-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f0f4f7;
            border-radius: 8px;
        }
        
        .canvas-mode-toggle .toggle-btn {
            padding: 8px 16px;
            border: 2px solid #bdc3c7;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .canvas-mode-toggle .toggle-btn.active {
            background: #27ae60;
            border-color: #27ae60;
            color: white;
        }
        
        .canvas-mode-toggle .toggle-btn:hover:not(.active) {
            border-color: #27ae60;
            background: #e8f8f5;
        }

        /* Calibration Mode */
        .calibration-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            pointer-events: auto;
        }
        
        .calibration-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            z-index: 100;
            background: rgba(0, 0, 0, 0.1);
        }
        
        /* Calibration panel - horizontal strip above video */
        .calibration-panel {
            display: none;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .calibration-panel.active {
            display: block;
        }
        
        .calibration-panel h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #f1c40f;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .calibration-panel p {
            font-size: 12px;
            margin: 0 0 10px 0;
            color: #ecf0f1;
        }
        
        .calibration-points-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 12px;
        }
        
        .calibration-point {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            padding: 4px 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            white-space: nowrap;
        }
        
        .calibration-point.done {
            background: rgba(39, 174, 96, 0.5);
        }
        
        .calibration-point.active {
            background: rgba(241, 196, 15, 0.5);
            border: 2px solid #f1c40f;
            animation: pulse-border 1s infinite;
        }
        
        @keyframes pulse-border {
            0%, 100% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0.4); }
            50% { box-shadow: 0 0 0 6px rgba(241, 196, 15, 0); }
        }
        
        .calibration-point .point-marker {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 10px;
            flex-shrink: 0;
        }
        
        .calibration-point.done .point-marker {
            background: #27ae60;
        }
        
        .calibration-point.active .point-marker {
            background: #f1c40f;
            color: #2c3e50;
        }
        
        .calibration-point:not(.done):not(.active) .point-marker {
            background: #7f8c8d;
        }
        
        .calibration-buttons {
            display: flex;
            gap: 10px;
        }
        
        .calibration-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .calibration-buttons .btn-undo {
            background: #e74c3c;
            color: white;
        }
        
        .calibration-buttons .btn-reset {
            background: #95a5a6;
            color: white;
        }
        
        .calibration-buttons .btn-confirm {
            background: #27ae60;
            color: white;
        }
        
        .calibration-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .calibration-buttons button:not(:disabled):hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        /* Current calibration point indicator on video */
        .calibration-current-indicator {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(241, 196, 15, 0.95);
            color: #2c3e50;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 13px;
            z-index: 102;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .calibration-current-indicator.active {
            display: block;
            animation: bounce-subtle 0.5s ease infinite alternate;
        }
        
        @keyframes bounce-subtle {
            from { transform: translateX(-50%) translateY(0); }
            to { transform: translateX(-50%) translateY(-3px); }
        }

        /* Court Overlay on Video */
        .court-overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            /* width/height set dynamically by JavaScript to match video */
            pointer-events: none;
            z-index: 50;
        }
        
        .court-overlay-canvas.interactive {
            pointer-events: auto;
            cursor: crosshair;
        }

        /* Click Marker */
        .click-marker {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(231, 76, 60, 0.8);
            border: 2px solid white;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 60;
            animation: pulse-marker 0.5s ease-out;
        }
        
        @keyframes pulse-marker {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        .click-marker.from-marker {
            background: rgba(52, 152, 219, 0.9);
        }
        
        .click-marker.to-marker {
            background: rgba(155, 89, 182, 0.9);
        }

        /* Coordinate Display */
        .coord-display {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(44, 62, 80, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: monospace;
            z-index: 70;
        }
        
        .coord-display .coord-value {
            color: #f1c40f;
            font-weight: 700;
        }
        
        .coord-display .zone-info {
            color: #2ecc71;
            margin-left: 10px;
        }

        /* Trajectory Selector */
        .trajectory-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 10px;
            background: #2c3e50;
            border-radius: 6px;
            margin-top: 10px;
        }
        
        .trajectory-selector label {
            font-size: 12px;
            color: #bdc3c7;
            font-weight: 600;
        }
        
        .trajectory-buttons {
            display: flex;
            gap: 5px;
        }
        
        .trajectory-btn {
            width: 36px;
            height: 36px;
            border: 2px solid #7f8c8d;
            background: #34495e;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 700;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .trajectory-btn:hover {
            border-color: #3498db;
            background: #2c3e50;
        }
        
        .trajectory-btn.active {
            border-color: #f1c40f;
            background: #f39c12;
            color: #2c3e50;
        }
        
        .trajectory-btn.default-traj {
            border-color: #27ae60;
        }
        
        .trajectory-display {
            font-size: 12px;
            color: #ecf0f1;
            margin-left: 10px;
        }
        
        .trajectory-display .traj-arrow {
            font-size: 16px;
            margin-right: 5px;
        }

        /* Shot Info Panel - Canvas Mode */
        .canvas-shot-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .canvas-shot-panel h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #2c3e50;
        }
        
        .canvas-shot-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .canvas-shot-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }
        
        .canvas-shot-row .label {
            font-weight: 600;
            color: #7f8c8d;
        }
        
        .canvas-shot-row .value {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .canvas-shot-row .value.coords {
            font-family: monospace;
            color: #3498db;
        }
        
        .canvas-shot-row .inferred-shot {
            background: #27ae60;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Calibration Status Indicator */
        .calibration-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .calibration-status.not-calibrated {
            background: #fdf2e9;
            color: #e67e22;
            border: 1px solid #e67e22;
        }
        
        .calibration-status.calibrated {
            background: #d4edda;
            color: #27ae60;
            border: 1px solid #27ae60;
        }
        
        .calibration-status .status-icon {
            font-size: 14px;
        }
        
        .debug-overlay-btn {
            margin-left: auto;
            padding: 4px 10px;
            border: none;
            border-radius: 4px;
            background: #9b59b6;
            color: white;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .debug-overlay-btn:hover {
            background: #8e44ad;
        }
        
        .debug-overlay-btn.active {
            background: #e74c3c;
        }

        /* Shot Mode Indicator - Shows when B (backhand) or D (dribble) is active */
        .shot-mode-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px 12px;
            margin-top: 4px;
            border-radius: 6px;
            background: #3498db;
            color: white;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            animation: pulse-indicator 1s infinite alternate;
        }

        @keyframes pulse-indicator {
            from { opacity: 0.8; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h1 style="margin: 0;">üè∏ Badminton Annotation Tool</h1>
            <div class="mode-selector">
                <span style="font-weight: 600; color: #2c3e50;">Mode:</span>
                <button class="mode-btn active" id="modeMatchBtn" onclick="setMode('match')">Match Analysis</button>
                <button class="mode-btn" id="modeTechnicalBtn" onclick="setMode('technical')">Technical</button>
                <button class="mode-btn" id="modeCourtBtn" onclick="setMode('court')">Court Position</button>
            </div>
        </div>
        
        <div class="file-input-wrapper">
            <input type="file" id="videoInput" accept="video/*">
        </div>

        <!-- Match Analysis & Technical Mode Container -->
        <div id="matchTechnicalContainer" class="court-mode-container active">
        <div class="workspace">
            <div class="left-column">
                <div class="video-section">
                    <div class="video-container">
                        <video id="videoPlayer" controls preload="metadata">
                            Your browser does not support the video tag.
                        </video>
                        <div class="video-info">
                            <div class="video-info-left">
                                <div>Frame: <span id="frameNumber">0</span></div>
                                <div>Time: <span id="currentTime">0.00</span>s</div>
                            </div>
                            <div class="frame-controls">
                                <span>c/v: ¬±10 frames</span>
                                <span>‚Üê ‚Üí: ¬±1 frame</span>
                                <span>‚Üë ‚Üì: prev/next tag</span>
                                <span>0: +400 frames</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-panel">
                    <div class="quick-access">
                        <div class="quick-group">
                            <div class="quick-title">
                                Recent Shots
                                <span class="quick-count" id="recentCount"></span>
                            </div>
                            <div class="quick-buttons" id="recentShots">
                                <span class="quick-empty">No recent shots yet.</span>
                            </div>
                        </div>
                        <div class="quick-group">
                            <div class="quick-title">
                                Top Shots
                                <span class="quick-count" id="favoriteCount"></span>
                            </div>
                            <div class="quick-buttons" id="favoriteShots">
                                <span class="quick-empty">Annotations will populate favorites.</span>
                            </div>
                        </div>
                    </div>

                    <div class="stats">
                        <span>Total: <strong id="totalCount">0</strong></span>
                        <span>
                            <form id="fpsForm" class="fps-form">
                                <label for="fpsInput">FPS</label>
                                <input type="number" id="fpsInput" min="1" step="0.01" value="30">
                                <button type="submit">Set</button>
                            </form>
                            <strong id="fpsDisplay">30</strong>
                        </span>
                        <span>Combo: <strong id="comboDisplay">-</strong></span>
                        <span class="last-annotation" id="lastAnnotation"></span>
                    </div>

                    <div class="frame-search-row">
                        <form id="frameSearchForm">
                            <label for="frameSearchInput">Go to frame</label>
                            <input type="number" id="frameSearchInput" min="0" placeholder="e.g. 1250">
                            <button type="submit" class="btn btn-primary btn-small">Go</button>
                        </form>
                    </div>

                    <div class="nav-buttons">
                    <button type="button" class="btn btn-secondary btn-small" onclick="jumpToPreviousAnnotation()">‚üµ Prev Annotation (‚Üë)</button>
                    <button type="button" class="btn btn-secondary btn-small" onclick="jumpToNextAnnotation()">Next Annotation (‚Üì) ‚ü∂</button>
                    </div>

                    <div class="import-controls">
                        <label for="csvImportInput">Import annotations CSV</label>
                        <input type="file" id="csvImportInput" accept=".csv,text/csv">
                    </div>
                </div>

                <div class="action-buttons">
                    <button class="btn btn-danger" onclick="undoAnnotation()">Undo Last</button>
                    <button class="btn btn-success" onclick="exportCSV()">Download CSV</button>
                    <button class="btn btn-warning" onclick="exportJSON()">Download JSON</button>
                    <button class="btn btn-primary" onclick="clearAll()">Clear All</button>
                    <button class="btn btn-secondary" onclick="showInfoModal()">‚ÑπÔ∏è Info</button>
                </div>
            </div>

            <div class="right-panel">
                <!-- Match Analysis Mode: Tags List -->
                <div id="matchModePanel" class="annotations-tags">
                    <h3>Tags</h3>
                    <div id="annotationsList" class="tags-list">
                        <div class="empty-state">No annotations yet. Type combos to start tagging.</div>
                    </div>
                </div>
                
                <!-- Technical Analysis Mode: Available Labels + Tagged Labels -->
                <div id="technicalModePanel" class="annotations-tags" style="display: none;">
                    <h3>Technical Labels</h3>
                    <div id="technicalLabelsList" class="technical-labels-grid">
                        <!-- Will be populated by JavaScript -->
                    </div>
                    
                    <div class="tagged-technical-section">
                        <div class="tagged-technical-header" onclick="toggleTaggedTechnical()">
                            <h4>Tagged Labels <span id="taggedTechnicalCount">(0)</span></h4>
                            <span id="taggedTechnicalToggle" class="toggle-icon">‚ñº</span>
                        </div>
                        <div id="taggedTechnicalList" class="tagged-technical-list" style="display: none;">
                            <div class="empty-state">No technical labels tagged yet.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="annotations-log" id="detailsLog">
            <h3>Annotation Details</h3>
            <div id="annotationsContainer">
                <div class="empty-state">No annotations yet. Type the shot combos (e.g., fs, bd, hs) to add annotations.</div>
            </div>
        </div>
        </div><!-- End matchTechnicalContainer -->

        <!-- Court Position Mode Container -->
        <div id="courtModeContainer" class="court-mode-container">
            <div class="court-workspace">
                <!-- Left Panel: Video Player -->
                <div class="court-left-panel">
                    <!-- Canvas/Zone Mode Toggle -->
                    <div class="canvas-mode-toggle">
                        <button class="toggle-btn" id="zoneModeBtn" onclick="setCourtInputMode('zone')">Zone Click</button>
                        <button class="toggle-btn active" id="canvasModeBtn" onclick="setCourtInputMode('canvas')">Canvas Click</button>
                        <button class="toggle-btn" id="calibrateBtn" onclick="startCalibration()">üìê Calibrate</button>
                    </div>
                    
                    <!-- Calibration Status -->
                    <div class="calibration-status not-calibrated" id="calibrationStatus">
                        <span class="status-icon">‚ö†Ô∏è</span>
                        <span id="calibrationStatusText">Not calibrated - Click "Calibrate" to set up court overlay</span>
                        <button class="debug-overlay-btn" id="debugOverlayBtn" onclick="toggleDebugOverlay()" style="display: none;">üé® Debug</button>
                    </div>

                    <!-- Shot Mode Indicator - Shows active modifiers (B=Backhand, D=Dribble) -->
                    <div id="shotModeIndicator" class="shot-mode-indicator" style="display: none;">
                        <!-- Content set by updateModeIndicators() -->
                    </div>

                    <!-- Calibration Panel - OUTSIDE video, above it -->
                    <div class="calibration-panel" id="calibrationPanel">
                        <h4>üìê Court Calibration ‚Äî Click on the video to mark 10 reference points</h4>
                        <div class="calibration-points-list" id="calibrationPointsList">
                            <div class="calibration-point active" data-point="0">
                                <span class="point-marker">1</span>
                                <span>P2 Baseline Left</span>
                            </div>
                            <div class="calibration-point" data-point="1">
                                <span class="point-marker">2</span>
                                <span>P2 Baseline Right</span>
                            </div>
                            <div class="calibration-point" data-point="2">
                                <span class="point-marker">3</span>
                                <span>P2 Service Line Left</span>
                            </div>
                            <div class="calibration-point" data-point="3">
                                <span class="point-marker">4</span>
                                <span>P2 Service Line Right</span>
                            </div>
                            <div class="calibration-point" data-point="4">
                                <span class="point-marker">5</span>
                                <span>Net Left</span>
                            </div>
                            <div class="calibration-point" data-point="5">
                                <span class="point-marker">6</span>
                                <span>Net Right</span>
                            </div>
                            <div class="calibration-point" data-point="6">
                                <span class="point-marker">7</span>
                                <span>P1 Service Line Left</span>
                            </div>
                            <div class="calibration-point" data-point="7">
                                <span class="point-marker">8</span>
                                <span>P1 Service Line Right</span>
                            </div>
                            <div class="calibration-point" data-point="8">
                                <span class="point-marker">9</span>
                                <span>P1 Baseline Left</span>
                            </div>
                            <div class="calibration-point" data-point="9">
                                <span class="point-marker">10</span>
                                <span>P1 Baseline Right</span>
                            </div>
                        </div>
                        <div class="calibration-buttons">
                            <button class="btn-undo" onclick="undoCalibrationPoint()" id="calibUndoBtn" disabled>Undo</button>
                            <button class="btn-reset" onclick="resetCalibration()">Reset</button>
                            <button class="btn-confirm" onclick="confirmCalibration()" id="calibConfirmBtn" disabled>Confirm</button>
                        </div>
                    </div>

                    <div class="video-section" style="position: relative;">
                        <div class="video-container" id="courtVideoContainer" style="position: relative;">
                            <video id="courtVideoPlayer" preload="metadata">
                                Your browser does not support the video tag.
                            </video>

                            <!-- Court Overlay Canvas (for drawing court lines and markers) -->
                            <canvas id="courtOverlayCanvas" class="court-overlay-canvas"></canvas>

                            <!-- Calibration Canvas (for clicking points) -->
                            <canvas id="calibrationCanvas" class="calibration-canvas" style="display: none;"></canvas>

                            <!-- Current point indicator on video during calibration -->
                            <div class="calibration-current-indicator" id="calibrationCurrentIndicator">
                                Click: Point 1 ‚Äî P2 Back-Left
                            </div>

                            <!-- Coordinate Display (shown when hovering in canvas mode) -->
                            <div id="coordDisplay" class="coord-display" style="display: none;">
                                Position: <span class="coord-value" id="coordValue">(0.0, 0.0)</span>
                                <span class="zone-info" id="zoneInfo">Zone: -</span>
                            </div>

                            <!-- Shot Toast Overlay (brief notification for each shot) -->
                            <div class="shot-toast" id="shotToast"></div>

                            <!-- Court Combo Indicator (shows typed combo for shot override) -->
                            <div class="court-combo-indicator" id="courtComboIndicator">
                                <div class="combo-keys"></div>
                                <div class="combo-shot"></div>
                            </div>

                            <div class="video-info">
                                <div class="video-info-left">
                                    <div>Frame: <span id="courtFrameNumber">0</span></div>
                                    <div>Time: <span id="courtCurrentTime">0.00</span>s</div>
                                </div>
                                <div class="frame-controls">
                                    <span>8/9: ¬±1f</span>
                                    <span>c/v: ¬±10f</span>
                                    <span>&lt;&gt;: Tags</span>
                                </div>
                            </div>
                        </div>

                        <!-- Custom Video Controls (outside canvas) -->
                        <div class="court-video-controls" id="courtVideoControls">
                            <button class="ctrl-btn play-pause" id="courtPlayPauseBtn" onclick="toggleCourtPlayPause()">
                                <span class="play-icon">‚ñ∂</span>
                                <span class="pause-icon" style="display:none;">‚ùö‚ùö</span>
                            </button>
                            <input type="range" class="video-seek" id="courtVideoSeek" min="0" max="100" value="0" step="0.1">
                            <span class="time-display" id="courtTimeDisplay">0:00 / 0:00</span>
                            <select class="speed-select" id="courtSpeedSelect" onchange="setCourtPlaybackSpeed()">
                                <option value="0.25">0.25x</option>
                                <option value="0.5">0.5x</option>
                                <option value="0.75">0.75x</option>
                                <option value="1" selected>1x</option>
                                <option value="1.25">1.25x</option>
                                <option value="1.5">1.5x</option>
                                <option value="2">2x</option>
                            </select>
                        </div>

                        <!-- Compact Shot Info Bar -->
                        <div class="compact-shot-bar" id="compactShotBar">
                            <div class="shot-segment">
                                <span class="segment-label">From:</span>
                                <span class="segment-value pending" id="compactFromZone">-</span>
                            </div>
                            <div class="shot-segment">
                                <span class="segment-label">To:</span>
                                <span class="segment-value pending" id="compactToZone">-</span>
                            </div>
                            <div class="shot-segment">
                                <span class="segment-label">Traj:</span>
                                <div class="traj-buttons">
                                    <button class="traj-btn" data-traj="-1" onclick="setTrajectory(-1)" title="Downward">‚Üì</button>
                                    <button class="traj-btn active" data-traj="0" onclick="setTrajectory(0)" title="Flat">‚Üí</button>
                                    <button class="traj-btn" data-traj="1" onclick="setTrajectory(1)" title="Upward">‚Üë</button>
                                </div>
                            </div>
                            <div class="shot-segment" id="compactShotTypeSegment" style="display: none;">
                                <span class="segment-label">Shot:</span>
                                <span class="shot-type-display" id="compactShotType">-</span>
                            </div>
                        </div>
                    </div>

                    <!-- Rally Control -->
                    <div class="rally-control-panel">
                        <h4>Rally Control</h4>
                        <div class="rally-buttons">
                            <button class="rally-btn new-rally" id="newRallyBtn" onclick="startNewRally()">New Rally (Enter)</button>
                            <button class="rally-btn p1-won" onclick="endRally('P1')" style="display: none;" id="p1WonBtn">P1 Won ( 1 )</button>
                            <button class="rally-btn p2-won" onclick="endRally('P2')" style="display: none;" id="p2WonBtn">P2 Won ( 2 )</button>
                        </div>
                        <div class="rally-buttons" style="margin-top: 8px;">
                            <button class="rally-btn undo" onclick="undoCourtShot()">Undo Shot (Bksp)</button>
                            <button class="rally-btn cancel" onclick="cancelCurrentShot()">Cancel (Esc)</button>
                        </div>
                        <div class="rally-buttons" style="margin-top: 8px;">
                            <button class="rally-btn undo" onclick="undoLastRallyWinner()" title="Undo the last rally winner selection">Undo Rally (U)</button>
                        </div>
                    </div>

                    <!-- Match Setup -->
                    <div class="match-setup-panel">
                        <h3>Match Setup</h3>
                        <div class="setup-row">
                            <label>P1:</label>
                            <input type="text" id="p1NameInput" placeholder="Player 1" value="P1">
                            <select id="p1HandInput">
                                <option value="right">R</option>
                                <option value="left">L</option>
                            </select>
                        </div>
                        <div class="setup-row">
                            <label>P2:</label>
                            <input type="text" id="p2NameInput" placeholder="Player 2" value="P2">
                            <select id="p2HandInput">
                                <option value="right">R</option>
                                <option value="left">L</option>
                            </select>
                        </div>
                        <div class="setup-row">
                            <label>FPS:</label>
                            <input type="number" id="courtFpsInput" min="1" step="0.01" value="30" style="width: 70px;">
                            <button class="btn btn-small btn-primary" onclick="setCourtFps()">Set</button>
                        </div>
                    </div>

                    <!-- Game Control -->
                    <div class="game-control-panel">
                        <h4>Game Control</h4>
                        <div class="game-buttons">
                            <button class="game-btn new-game" onclick="startNewGame()">New Game</button>
                            <button class="game-btn end-game" onclick="endCurrentGame()">End Game</button>
                        </div>
                        <div class="court-export-buttons">
                            <button class="btn btn-info btn-small" onclick="document.getElementById('courtCsvImport').click()">Import</button>
                            <input type="file" id="courtCsvImport" accept=".csv" style="display: none;" onchange="importCourtCSV(this)">
                            <button class="btn btn-success btn-small" onclick="exportCourtCSV()">CSV</button>
                            <button class="btn btn-warning btn-small" onclick="exportCourtJSON()">JSON</button>
                            <button class="btn btn-danger btn-small" onclick="clearCourtData()" title="Clear annotations (keep calibration)">Clear</button>
                            <button class="btn btn-danger btn-small" onclick="clearAllStoredData()" title="Clear ALL data" style="background: #8e44ad;">Reset</button>
                            <button class="btn btn-secondary btn-small" onclick="showCourtHelpModal()">?</button>
                        </div>
                    </div>
                </div>

                <!-- Center Panel: Court Map -->
                <div class="court-center-panel">
                    <div class="court-map-container">
                        <div class="court-map" id="courtMap">
                            <!-- P2's Court (Top) - Simplified 3-area system -->
                            <!-- P2 faces DOWN: their RIGHT is x<2.59 (screen left), their LEFT is x>2.59 (screen right) -->
                            <div class="player-label p2"><span id="p2NameDisplay">P2</span>'s Court</div>
                            <div class="court-half p2" id="courtP2">
                                <div class="court-row">
                                    <div class="court-zone back-zone" data-zone="5b" data-player="P2">
                                        <span class="zone-number">5</span>
                                        <span class="zone-name">Back FH</span>
                                    </div>
                                    <div class="court-zone back-zone" data-zone="6b" data-player="P2">
                                        <span class="zone-number">6</span>
                                        <span class="zone-name">Back BH</span>
                                    </div>
                                </div>
                                <div class="court-row">
                                    <div class="court-zone mid-zone" data-zone="3b" data-player="P2">
                                        <span class="zone-number">3</span>
                                        <span class="zone-name">Mid FH</span>
                                    </div>
                                    <div class="court-zone mid-zone" data-zone="4b" data-player="P2">
                                        <span class="zone-number">4</span>
                                        <span class="zone-name">Mid BH</span>
                                    </div>
                                </div>
                                <div class="court-row">
                                    <div class="court-zone front-zone" data-zone="1b" data-player="P2">
                                        <span class="zone-number">1</span>
                                        <span class="zone-name">Front FH</span>
                                    </div>
                                    <div class="court-zone front-zone" data-zone="2b" data-player="P2">
                                        <span class="zone-number">2</span>
                                        <span class="zone-name">Front BH</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Net -->
                            <div class="court-net"></div>

                            <!-- P1's Court (Bottom) - Simplified 3-area system -->
                            <!-- P1 faces UP: their LEFT is x<2.59 (screen left), their RIGHT is x>2.59 (screen right) -->
                            <div class="court-half p1" id="courtP1">
                                <div class="court-row">
                                    <div class="court-zone front-zone" data-zone="2a" data-player="P1">
                                        <span class="zone-number">2</span>
                                        <span class="zone-name">Front BH</span>
                                    </div>
                                    <div class="court-zone front-zone" data-zone="1a" data-player="P1">
                                        <span class="zone-number">1</span>
                                        <span class="zone-name">Front FH</span>
                                    </div>
                                </div>
                                <div class="court-row">
                                    <div class="court-zone mid-zone" data-zone="4a" data-player="P1">
                                        <span class="zone-number">4</span>
                                        <span class="zone-name">Mid BH</span>
                                    </div>
                                    <div class="court-zone mid-zone" data-zone="3a" data-player="P1">
                                        <span class="zone-number">3</span>
                                        <span class="zone-name">Mid FH</span>
                                    </div>
                                </div>
                                <div class="court-row">
                                    <div class="court-zone back-zone" data-zone="6a" data-player="P1">
                                        <span class="zone-number">6</span>
                                        <span class="zone-name">Back BH</span>
                                    </div>
                                    <div class="court-zone back-zone" data-zone="5a" data-player="P1">
                                        <span class="zone-number">5</span>
                                        <span class="zone-name">Back FH</span>
                                    </div>
                                </div>
                            </div>
                            <div class="player-label p1"><span id="p1NameDisplay">P1</span>'s Court</div>
                        </div>
                    </div>

                    <!-- Current Shot Display -->
                    <div class="current-shot-display" id="currentShotDisplay">
                        <h4>Current Shot</h4>
                        <div class="shot-info">
                            <div class="from-zone">
                                <span class="zone-label">From:</span>
                                <span class="zone-value pending" id="fromZoneDisplay">-</span>
                                <span class="zone-value coords" id="fromCoordsDisplay" style="display: none; margin-left: 8px;"></span>
                            </div>
                            <div class="to-zone">
                                <span class="zone-label">To:</span>
                                <span class="zone-value pending" id="toZoneDisplay">-</span>
                                <span class="zone-value coords" id="toCoordsDisplay" style="display: none; margin-left: 8px;"></span>
                            </div>
                            <div class="shot-type" id="shotTypeDisplay" style="display: none;">
                                Shot: <span id="inferredShotType">-</span>
                            </div>
                        </div>
                        
                        <!-- Trajectory Selector -->
                        <div class="trajectory-selector" id="trajectorySelector" style="display: none;">
                            <label>Trajectory:</label>
                            <div class="trajectory-buttons">
                                <button class="trajectory-btn" data-traj="-1" onclick="setTrajectory(-1)" title="Downward (1)">‚Üì</button>
                                <button class="trajectory-btn" data-traj="0" onclick="setTrajectory(0)" title="Flat (2)">‚Üí</button>
                                <button class="trajectory-btn" data-traj="1" onclick="setTrajectory(1)" title="Upward (3)">‚Üë</button>
                            </div>
                            <div class="trajectory-display">
                                <span class="traj-arrow" id="trajArrowDisplay">‚Üí</span>
                                <span id="trajTextDisplay">Flat (default)</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right Panel: Score + Rally Log -->
                <div class="court-right-panel">
                    <!-- Score Display -->
                    <div class="score-display">
                        <div class="game-info">Game <span id="currentGameNum">1</span></div>
                        <div class="score-main">
                            <div class="player-score">
                                <span class="player-name" id="scoreP1Name">P1</span>
                                <span class="score-num" id="scoreP1">0</span>
                            </div>
                            <span class="vs">-</span>
                            <div class="player-score">
                                <span class="player-name" id="scoreP2Name">P2</span>
                                <span class="score-num" id="scoreP2">0</span>
                            </div>
                        </div>
                        <div class="rally-info">Rally <span id="currentRallyNum">1</span> ‚Ä¢ <span id="serverIndicator">Waiting for server...</span></div>
                    </div>

                    <!-- Rally Log -->
                    <div class="rally-log-panel">
                        <div class="rally-log-header">
                            <h3>Rally Log</h3>
                            <select id="shotTypeFilter" onchange="updateRallyLog()">
                                <option value="">All Shots</option>
                                <option value="serve">Serves</option>
                                <option value="smash">Smash</option>
                                <option value="clear">Clear</option>
                                <option value="drop">Drop</option>
                                <option value="pulldrop">Pull Drop</option>
                                <option value="drive">Drive</option>
                                <option value="defense">Defense</option>
                                <option value="block">Block</option>
                                <option value="lift">Lift</option>
                                <option value="nettap">Net Tap</option>
                                <option value="netkeep">Net Keep</option>
                                <option value="push">Push</option>
                                <option value="dribble">Dribble</option>
                                <option value="flatgame">Flat Game</option>
                            </select>
                        </div>
                        <div id="rallyLogContent">
                            <div class="empty-state">No rallies yet. Press Enter to start a new rally.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div><!-- End courtModeContainer -->

        <!-- Server Selection Modal -->
        <div class="server-modal" id="serverModal">
            <div class="server-modal-content">
                <h3>Who is serving?</h3>
                <div class="server-buttons">
                    <button class="server-btn p1" onclick="selectServer('P1')">
                        <span id="serverModalP1Name">P1</span> (1)
                    </button>
                    <button class="server-btn p2" onclick="selectServer('P2')">
                        <span id="serverModalP2Name">P2</span> (2)
                    </button>
                </div>
            </div>
        </div>

    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toastNotification"></div>

    <!-- Keyboard Legend -->
    <button class="toggle-legend" onclick="toggleLegend()" title="Show keyboard shortcuts (? key)">?</button>
    <div class="keyboard-legend" id="keyboardLegend">
        <h4>‚å®Ô∏è Keyboard Shortcuts</h4>
        <div id="legendContent"></div>
    </div>

    <!-- Search Panel -->
    <button class="toggle-search" onclick="toggleSearch(true)" title="Search shots (Ctrl+F or /)">üîç</button>
    <div class="search-bar" id="searchBar">
        <input type="text" class="search-input" id="searchInput" placeholder="Type to search shots..." autocomplete="off">
        <div class="search-results" id="searchResults"></div>
    </div>

    <!-- Info Modal -->
    <div class="info-modal" id="infoModal">
        <div class="info-modal-content">
            <div class="info-modal-header">
                <h2>üìä Video Information</h2>
                <button class="info-modal-close" onclick="closeInfoModal()">&times;</button>
            </div>
            <div id="infoModalBody">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Court Position Mode Help Modal -->
    <div class="info-modal" id="courtHelpModal">
        <div class="info-modal-content" style="max-width: 700px;">
            <div class="info-modal-header">
                <h2>Court Position Mode Guide</h2>
                <button class="info-modal-close" onclick="closeCourtHelpModal()">&times;</button>
            </div>
            <div class="court-help-body">
                <div class="help-section">
                    <h3>Workflow</h3>
                    <ol>
                        <li><strong>Calibrate Court:</strong> Click "Calibrate" and mark 10 points on the video court</li>
                        <li><strong>Start Rally:</strong> Press <kbd>Enter</kbd> to start a new rally</li>
                        <li><strong>Select Server:</strong> Click P1 or P2 in the modal</li>
                        <li><strong>Record Shots:</strong> Click landing zone on court map for each shot</li>
                        <li><strong>End Rally:</strong> Press <kbd>1</kbd> (P1 wins) or <kbd>2</kbd> (P2 wins)</li>
                    </ol>
                </div>

                <div class="help-section">
                    <h3>Keyboard Shortcuts</h3>
                    <table class="help-shortcuts-table">
                        <tr><td><kbd>Enter</kbd></td><td>Start new rally</td></tr>
                        <tr><td><kbd>Space</kbd></td><td>Play/Pause video</td></tr>
                        <tr><td><kbd>1</kbd></td><td>P1 wins rally</td></tr>
                        <tr><td><kbd>2</kbd></td><td>P2 wins rally</td></tr>
                        <tr><td><kbd>8</kbd></td><td>Previous frame (‚àí1)</td></tr>
                        <tr><td><kbd>9</kbd></td><td>Next frame (+1)</td></tr>
                        <tr><td><kbd>c/v</kbd></td><td>Navigate ¬±10 frames *</td></tr>
                        <tr><td><kbd>&lt;</kbd></td><td>Previous annotation</td></tr>
                        <tr><td><kbd>&gt;</kbd></td><td>Next annotation</td></tr>
                        <tr><td><kbd>‚Üë ‚Üì ‚Üí</kbd></td><td>Trajectory (up/down/flat)</td></tr>
                        <tr><td><kbd>B</kbd></td><td>Toggle backhand mode *</td></tr>
                        <tr><td><kbd>D</kbd></td><td>Toggle dribble mode *</td></tr>
                        <tr><td><kbd>U</kbd></td><td>Undo last rally winner *</td></tr>
                        <tr><td><kbd>Bksp</kbd></td><td>Undo last shot</td></tr>
                        <tr><td><kbd>Esc</kbd></td><td>Cancel/Clear combo</td></tr>
                    </table>
                    <p style="font-size: 10px; color: #888; margin-top: 6px;">
                        * Disabled during combo mode (after clicking FROM zone). Use 8/9 for frames.
                    </p>
                </div>

                <div class="help-section">
                    <h3>Shot Type Override (Combos)</h3>
                    <p style="font-size: 12px; color: #555; margin-bottom: 8px;">
                        After clicking FROM zone, type a combo to override auto-detected shot type:
                    </p>
                    <table class="help-shortcuts-table">
                        <tr><td><kbd>fs</kbd></td><td>Forehand Smash</td></tr>
                        <tr><td><kbd>fc</kbd></td><td>Forehand Clear</td></tr>
                        <tr><td><kbd>fd</kbd></td><td>Forehand Drop</td></tr>
                        <tr><td><kbd>fl</kbd></td><td>Forehand Lift</td></tr>
                        <tr><td><kbd>fp</kbd></td><td>Forehand Push</td></tr>
                        <tr><td><kbd>fdr</kbd></td><td>Forehand Drive</td></tr>
                        <tr><td><kbd>fdf</kbd></td><td>Forehand Defense</td></tr>
                        <tr><td><kbd>fnk</kbd></td><td>Forehand Net Keep</td></tr>
                        <tr><td><kbd>fdb</kbd></td><td>Forehand Dribble</td></tr>
                        <tr><td><kbd>bs/bc/bd...</kbd></td><td>Backhand (same pattern)</td></tr>
                        <tr><td><kbd>os/oc/od</kbd></td><td>Overhead Smash/Clear/Drop</td></tr>
                    </table>
                    <p style="font-size: 10px; color: #888; margin-top: 6px;">
                        Combo mode activates after clicking FROM zone. Press Esc to cancel.
                    </p>
                </div>

                <div class="help-section">
                    <h3>Court Zones (6-Zone System)</h3>
                    <div class="help-zones-grid">
                        <div class="help-zone"><span>1</span> Front FH</div>
                        <div class="help-zone"><span>2</span> Front BH</div>
                        <div class="help-zone"><span>3</span> Mid FH</div>
                        <div class="help-zone"><span>4</span> Mid BH</div>
                        <div class="help-zone"><span>5</span> Back FH</div>
                        <div class="help-zone"><span>6</span> Back BH</div>
                    </div>
                    <p style="font-size: 11px; color: #666; margin-top: 8px;">
                        FH = Forehand side, BH = Backhand side (based on player handedness)
                    </p>
                </div>

                <div class="help-section">
                    <h3>Shot Type Detection</h3>
                    <p style="font-size: 12px; color: #555;">
                        Shot types are automatically inferred from:
                    </p>
                    <ul style="font-size: 12px; color: #555; margin: 5px 0 0 20px;">
                        <li><strong>From/To zones:</strong> Where shot starts and lands</li>
                        <li><strong>Trajectory:</strong> Upward (+1), Flat (0), or Downward (-1)</li>
                        <li><strong>Cross-court:</strong> Detected when FH‚ÜîBH zones change</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Shot data organized by category
        const shotCategories = {
            serves: [
                { name: "serve_middle", id: 318, color: "#dd97b3" },
                { name: "serve_corner", id: 319, color: "#ce6bbc" },
                { name: "serve_t", id: 330, color: "#8d7cc7" },
                { name: "flick_serve", id: 320, color: "#ae9901" },
                { name: "high_serve", id: 321, color: "#37647d" }
            ],
            forehand: [
                { name: "forehand_smash", id: 293, color: "#871478" },
                { name: "forehand_drop", id: 294, color: "#c5fb94" },
                { name: "forehand_clear", id: 295, color: "#b9866f" },
                { name: "forehand_defense", id: 296, color: "#e7566a" },
                { name: "forehand_pulldrop", id: 297, color: "#9dc2ad" },
                { name: "forehand_netkeep", id: 298, color: "#c8ad79" },
                { name: "forehand_dribble", id: 299, color: "#e7a365" },
                { name: "forehand_push", id: 300, color: "#f4b177" },
                { name: "forehand_nettap", id: 301, color: "#468f17" },
                { name: "forehand_lift", id: 302, color: "#a1d8f2" },
                { name: "forehand_drive", id: 325, color: "#b08aba" }
            ],
            backhand: [
                { name: "backhand_smash", id: 303, color: "#f28ca1" },
                { name: "backhand_clear", id: 304, color: "#9b8cf2" },
                { name: "backhand_drop", id: 305, color: "#8ff2c1" },
                { name: "backhand_pulldrop", id: 306, color: "#f2c78c" },
                { name: "backhand_defense", id: 307, color: "#d88cf2" },
                { name: "backhand_lift", id: 308, color: "#8cf2a9" },
                { name: "backhand_dribble", id: 309, color: "#f28e61" },
                { name: "backhand_netkeep", id: 310, color: "#cfc88c" },
                { name: "backhand_push", id: 311, color: "#8ca9f2" },
                { name: "backhand_nettap", id: 312, color: "#b6f28c" },
                { name: "backhand_drive", id: 326, color: "#4ec359" }
            ],
            overhead: [
                { name: "overhead_smash", id: 313, color: "#f29b8c" },
                { name: "overhead_clear", id: 314, color: "#8cf2e3" },
                { name: "overhead_drop", id: 315, color: "#dc8cf2" },
                { name: "overhead_halfsmash", id: 316, color: "#f2df8c" }
            ],
            other: [
                { name: "flat_game", id: 317, color: "#ff4308" },
                { name: "cross", id: 322, color: "#731c07" },
                { name: "P0", id: 323, color: "#f9188c", shortcut: '1' },
                { name: "P1", id: 324, color: "#20d603", shortcut: '2' }
            ]
        };

        // Technical Analysis Labels
        const technicalLabels = [
            { id: 400, abbreviation: "SPU", name: "Squat Position Upright", description: "Squat position upright" },
            { id: 401, abbreviation: "RCBW", name: "Racquet Carriage Below Waist", description: "Racquet carriage below waist" },
            { id: 402, abbreviation: "AEETL", name: "Arm and Elbow Extension Too Low", description: "Arm and elbow extension too low" },
            { id: 403, abbreviation: "XF", name: "X Factor Too Low", description: "X factor too low" },
            { id: 404, abbreviation: "FPP", name: "Feet Position Parallel", description: "Feet position parallel" },
            { id: 405, abbreviation: "DPTF", name: "Defense Position Too Far Forward", description: "Defense position too far forward" },
            { id: 406, abbreviation: "LSTW", name: "Leg Stance Too Wide", description: "Leg stance too wide" },
            { id: 407, abbreviation: "MVRM", name: "Movement to the Center Running", description: "Movement to the center running" },
            { id: 408, abbreviation: "LSTC", name: "Leg Stance Too Close", description: "Leg stance too close" },
            { id: 409, abbreviation: "DPEJ", name: "Defense Position Extra Jump", description: "Defense position extra jump" },
            { id: 410, abbreviation: "UBCBN", name: "Upper Body and Core Bent", description: "Upper body and core bent" },
            { id: 411, abbreviation: "RHTI", name: "Racquet Hand Tucked In", description: "Racquet hand tucked in" },
            { id: 412, abbreviation: "NRHTI", name: "Non Racquet Hand Tucked In", description: "Non racquet hand tucked in" },
            { id: 413, abbreviation: "PALTC", name: "Posture After Landing Too Close", description: "Posture after landing too close" },
            { id: 414, abbreviation: "RCPTL", name: "Receive Contact Point Too Low", description: "Receive contact point too low" },
            { id: 415, abbreviation: "MVCL", name: "Movement to the Centre Crossed Leg", description: "Movement to the centre crossed leg" },
            { id: 416, abbreviation: "CPTL", name: "Contact Point Too Low", description: "Contact point too low" },
            { id: 417, abbreviation: "RFT", name: "racquet follow through", description: "racquet follow through" }
        ];

        // Technical labels lookup
        const technicalLabelLookup = new Map();
        technicalLabels.forEach(label => {
            technicalLabelLookup.set(label.abbreviation, label);
            technicalLabelLookup.set(label.name, label);
        });

        // Flatten all shots and build lookups
        const allShots = [
            ...shotCategories.serves,
            ...shotCategories.forehand,
            ...shotCategories.backhand,
            ...shotCategories.overhead,
            ...shotCategories.other
        ];

        const shotLookup = new Map();
        allShots.forEach(shot => {
            shotLookup.set(shot.name, shot);
        });

        const comboDefinitions = [
            // Forehand
            { combo: 'fs', shot: 'forehand_smash' },
            { combo: 'fc', shot: 'forehand_clear' },
            { combo: 'fdr', shot: 'forehand_drive' },
            { combo: 'fd', shot: 'forehand_drop' },
            { combo: 'fdf', shot: 'forehand_defense' },
            { combo: 'fpd', shot: 'forehand_pulldrop' },
            { combo: 'fnk', shot: 'forehand_netkeep' },
            { combo: 'fdb', shot: 'forehand_dribble' },
            { combo: 'fp', shot: 'forehand_push' },
            { combo: 'fnt', shot: 'forehand_nettap' },
            { combo: 'fl', shot: 'forehand_lift' },
            // Backhand
            { combo: 'bs', shot: 'backhand_smash' },
            { combo: 'bc', shot: 'backhand_clear' },
            { combo: 'bdr', shot: 'backhand_drive' },
            { combo: 'bd', shot: 'backhand_drop' },
            { combo: 'bdf', shot: 'backhand_defense' },
            { combo: 'bpd', shot: 'backhand_pulldrop' },
            { combo: 'bnk', shot: 'backhand_netkeep' },
            { combo: 'bdb', shot: 'backhand_dribble' },
            { combo: 'bp', shot: 'backhand_push' },
            { combo: 'bnt', shot: 'backhand_nettap' },
            { combo: 'bl', shot: 'backhand_lift' },
            // Overhead
            { combo: 'os', shot: 'overhead_smash' },
            { combo: 'oc', shot: 'overhead_clear' },
            { combo: 'od', shot: 'overhead_drop' },
            { combo: 'ohs', shot: 'overhead_halfsmash' },
            // Serves
            { combo: 'w', shot: 'serve_middle' },
            { combo: 'e', shot: 'serve_corner' },
            { combo: 'r', shot: 'serve_t' },
            { combo: 'q', shot: 'flick_serve' },
            { combo: 'hs', shot: 'high_serve' },
            // Other
            { combo: 'fg', shot: 'flat_game' },
            // Note: 'xx' is handled specially - it adds cross to existing tags, not a separate tag
            { combo: '1', shot: 'P0' },
            { combo: '2', shot: 'P1' }
        ];

        const comboToShot = new Map();
        const shotPrimaryCombo = new Map(); // shot name -> primary combo
        const comboPrefixes = new Set();

        comboDefinitions.forEach(({ combo, shot }) => {
            const shotObj = shotLookup.get(shot);
            if (!shotObj) {
                console.warn(`Combo '${combo}' references unknown shot '${shot}'`);
                return;
            }

            comboToShot.set(combo, shotObj);

            if (!shotPrimaryCombo.has(shot)) {
                shotPrimaryCombo.set(shot, combo);
            }

            for (let i = 1; i <= combo.length; i += 1) {
                comboPrefixes.add(combo.slice(0, i));
            }
            const crossCombo = `${combo}x`;
            for (let i = 1; i <= crossCombo.length; i += 1) {
                comboPrefixes.add(crossCombo.slice(0, i));
            }
        });

        // Technical label combos (abbreviation -> technical label)
        const technicalComboToLabel = new Map();
        const technicalComboPrefixes = new Set();
        
        technicalLabels.forEach(label => {
            const abbr = label.abbreviation.toUpperCase();
            technicalComboToLabel.set(abbr, label);
            
            // Add all prefixes for autocomplete
            for (let i = 1; i <= abbr.length; i += 1) {
                technicalComboPrefixes.add(abbr.slice(0, i));
            }
        });

        // State
        let annotations = [];
        let video = null;
        let videoFileName = null; // Store the loaded video filename
        let fps = 30; // Default FPS, will be detected from video
        let frameRate = 1 / 30;
        let lastShot = null; // For repeat last shot
        let legendVisible = false;
        let isTechnicalMode = false; // false = Match Analysis, true = Technical Analysis
        const RECENT_LIMIT = 8;
        const FAVORITE_LIMIT = 8;
        let recentShotsList = [];
        const shotUsageCounts = new Map();

        allShots.forEach(shot => {
            shotUsageCounts.set(shot.name, 0);
        });

        let searchVisible = false;
        let comboDisplayEl = null;
        let comboBuffer = '';
        let comboTimer = null;
        let pendingShot = null;
        let pendingTimer = null;
        let comboErrorTimeout = null;
        let comboSuccessTimeout = null;
        let lastAnnotationFrame = null; // Track the frame of the last annotation added
        let editingAnnotationIndex = null; // Track which annotation is being edited (null = not editing)
        const COMBO_BUFFER_TIMEOUT = 1200;
        const PENDING_COMMIT_TIMEOUT = 350;

        // Load annotations from localStorage
        function loadAnnotations() {
            const saved = localStorage.getItem('badmintonAnnotations');
            if (saved) {
                annotations = JSON.parse(saved);
                updateAnnotationsDisplay();
                rebuildQuickAccessData();
            }
        }

        // Save annotations to localStorage
        function saveAnnotations() {
            localStorage.setItem('badmintonAnnotations', JSON.stringify(annotations));
        }

        // Initialize
        function init() {
            video = document.getElementById('videoPlayer');
            comboDisplayEl = document.getElementById('comboDisplay');
            resetComboBuffer();
            
            if (!video) {
                console.error('Video player element not found!');
                return;
            }

            // File input
            const videoInput = document.getElementById('videoInput');
            if (!videoInput) {
                console.error('Video input element not found!');
                return;
            }

            const fpsForm = document.getElementById('fpsForm');
            if (fpsForm) {
                fpsForm.addEventListener('submit', handleFpsSubmit);
            }

            const fpsInput = document.getElementById('fpsInput');
            if (fpsInput) {
                fpsInput.value = fps;
            }

            const frameForm = document.getElementById('frameSearchForm');
            if (frameForm) {
                frameForm.addEventListener('submit', handleFrameSearchSubmit);
            }

            const csvImportInput = document.getElementById('csvImportInput');
            if (csvImportInput) {
                csvImportInput.addEventListener('change', handleCsvImport);
            }
            
            videoInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    console.log('File selected:', file.name, file.type);
                    
                    // Store the video filename for CSV export
                    videoFileName = file.name;
                    
                    // Also load into court video player
                    const courtVideoEl = document.getElementById('courtVideoPlayer');
                    if (courtVideoEl) {
                        if (courtVideoEl.src && courtVideoEl.src.startsWith('blob:')) {
                            URL.revokeObjectURL(courtVideoEl.src);
                        }
                        const courtUrl = URL.createObjectURL(file);
                        courtVideoEl.src = courtUrl;
                        courtVideoEl.load();
                        
                        // Setup court video time update
                        courtVideoEl.addEventListener('timeupdate', updateCourtFrameInfo);
                        courtVideoEl.addEventListener('loadedmetadata', function() {
                            updateCourtFrameInfo();
                        });
                    }
                    
                    // Check file extension for potential codec issues
                    const fileName = file.name.toLowerCase();
                    const fileExt = fileName.substring(fileName.lastIndexOf('.') + 1);
                    
                    // Warn about potentially unsupported formats
                    if (fileExt === 'hevc' || fileName.includes('h265') || fileName.includes('hevc')) {
                        const proceed = confirm(
                            'Warning: H.265/HEVC videos are not supported in Chrome/Edge.\n\n' +
                            'This video may not play. Recommended:\n' +
                            '‚Ä¢ Convert to H.264/MP4 format\n' +
                            '‚Ä¢ Use Firefox or Safari browser\n\n' +
                            'Do you want to try loading it anyway?'
                        );
                        if (!proceed) {
                            e.target.value = ''; // Reset file input
                            return;
                        }
                    }
                    
                    // Revoke previous URL if exists
                    if (video.src && video.src.startsWith('blob:')) {
                        URL.revokeObjectURL(video.src);
                    }
                    
                    const url = URL.createObjectURL(file);
                    console.log('Created blob URL:', url);
                    
                    // Set video source
                    video.src = url;
                    
                    // Load the video
                    video.load();
                    console.log('Video load() called');
                    
                    // Add error handler
                    const errorHandler = function() {
                        console.error('Video error:', video.error);
                        console.error('Error code:', video.error ? video.error.code : 'unknown');
                        console.error('Error message:', video.error ? video.error.message : 'unknown');
                        
                        // Log system information for debugging
                        console.log('=== System Information ===');
                        console.log('User Agent:', navigator.userAgent);
                        console.log('Platform:', navigator.platform);
                        console.log('Video file:', file.name);
                        console.log('Video file type:', file.type);
                        console.log('Video file size:', (file.size / 1024 / 1024).toFixed(2), 'MB');
                        console.log('Video readyState:', video.readyState);
                        console.log('Video canPlayType("video/mp4"):', video.canPlayType('video/mp4'));
                        console.log('Video canPlayType("video/mp4; codecs="hev1.1.6.L93.B0""):', video.canPlayType('video/mp4; codecs="hev1.1.6.L93.B0"'));
                        console.log('Video canPlayType("video/mp4; codecs="hvc1.1.6.L93.B0""):', video.canPlayType('video/mp4; codecs="hvc1.1.6.L93.B0"'));
                        console.log('========================');
                        
                        let errorMessage = 'Error loading video. ';
                        const error = video.error;
                        
                        if (error) {
                            const errorMsg = error.message || '';
                            
                            // Check for specific error types
                            if (errorMsg.includes('DEMUXER_ERROR_NO_SUPPORTED_STREAMS') || 
                                errorMsg.includes('no supported streams')) {
                                errorMessage += '\n\nThis usually means:\n';
                                errorMessage += '‚Ä¢ The video codec (likely H.265/HEVC) is not supported\n';
                                errorMessage += '‚Ä¢ Your system lacks hardware acceleration for this codec\n\n';
                                
                                // Detect OS and provide specific guidance
                                const userAgent = navigator.userAgent.toLowerCase();
                                const isMac = userAgent.includes('mac');
                                const isWindows = userAgent.includes('win');
                                const isLinux = userAgent.includes('linux');
                                
                                errorMessage += 'Why it might work on other devices:\n';
                                if (isWindows) {
                                    errorMessage += '‚Ä¢ macOS has built-in H.265 hardware decoder support\n';
                                    errorMessage += '‚Ä¢ MacBook Air likely has hardware decoder (Intel/Apple Silicon)\n';
                                    errorMessage += '‚Ä¢ Windows Chrome relies on GPU/CPU hardware acceleration\n';
                                    errorMessage += '‚Ä¢ Your Dell laptop may not have compatible hardware decoder\n';
                                } else if (isMac) {
                                    errorMessage += '‚Ä¢ Different Mac models have varying hardware decoder support\n';
                                    errorMessage += '‚Ä¢ Older Macs may lack H.265 hardware acceleration\n';
                                } else {
                                    errorMessage += '‚Ä¢ Hardware decoder support varies by device/GPU\n';
                                    errorMessage += '‚Ä¢ Some systems have hardware acceleration, others don\'t\n';
                                }
                                
                                errorMessage += '\nSolutions:\n';
                                errorMessage += '‚Ä¢ Convert video to H.264 (AVC) codec (works everywhere)\n';
                                errorMessage += '‚Ä¢ Use MP4 container with H.264 video\n';
                                errorMessage += '‚Ä¢ Try Firefox or Safari (better codec support)\n';
                                errorMessage += '‚Ä¢ Use a video converter like HandBrake or FFmpeg\n';
                                errorMessage += '‚Ä¢ Check if your GPU supports H.265 hardware decoding';
                            } else if (error.code === 4) { // MEDIA_ERR_SRC_NOT_SUPPORTED
                                errorMessage += '\n\nThe video format is not supported.\n';
                                errorMessage += 'Supported formats: MP4 (H.264), WebM, OGG\n';
                                errorMessage += 'Recommended: MP4 with H.264 codec';
                            } else if (error.code === 3) { // MEDIA_ERR_DECODE
                                errorMessage += '\n\nThe video file appears to be corrupted or uses an unsupported codec.\n';
                                errorMessage += 'Try converting the video to H.264/MP4 format.';
                            } else {
                                errorMessage += '\n\nError details: ' + errorMsg;
                            }
                        } else {
                            errorMessage += 'Unknown error occurred.';
                        }
                        
                        alert(errorMessage);
                    };
                    video.addEventListener('error', errorHandler, { once: true });
                    
                    // Add loadeddata handler to verify video loaded
                    video.addEventListener('loadeddata', function() {
                        console.log('Video loaded successfully');
                        console.log('Video duration:', video.duration);
                        console.log('Video dimensions:', video.videoWidth, 'x', video.videoHeight);
                    }, { once: true });
                    
                    // Add canplay handler
                    video.addEventListener('canplay', function() {
                        console.log('Video can play');
                    }, { once: true });
                } else {
                    console.log('No file selected');
                }
            });

            // Video event listeners
            video.addEventListener('loadedmetadata', function() {
                // Default to 30 fps if not detected
                fps = 30;
                frameRate = 1 / fps;
                updateFPSDisplay();
                updateFrameInfo();
            });

            video.addEventListener('timeupdate', function() {
                updateFrameInfo();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                // Skip this handler when in Court mode - Court mode has its own keyboard handler
                if (currentMode === 'court') return;

                const tagName = e.target.tagName;
                const isInput = tagName === 'INPUT' || tagName === 'TEXTAREA';
                const isButton = tagName === 'BUTTON';
                const isSelect = tagName === 'SELECT';
                const isContentEditable = e.target.isContentEditable;
                const key = e.key;
                const lowerKey = key.length === 1 ? key.toLowerCase() : key.toLowerCase();
                const hasModifier = e.ctrlKey || e.metaKey || e.altKey;

                // Spacebar: play/pause (only outside interactive elements)
                if ((key === ' ' || key === 'Spacebar' || e.code === 'Space')) {
                    // Don't interfere if user is interacting with form elements, buttons, or contenteditable
                    if (isInput || isButton || isSelect || isContentEditable) {
                        return; // Let browser handle it normally for these elements
                    }
                    
                    // Prevent default to stop browser's native spacebar handling
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Handle play/pause for video
                    if (video && video.readyState >= 2) {
                        if (video.paused) {
                            video.play().catch(err => {
                                // Silently handle play promise rejection (e.g., autoplay policy)
                                console.log('Video play prevented by browser policy');
                            });
                        } else {
                            video.pause();
                        }
                    }
                    return;
                }

                // Search toggles
                if (!isInput && ((lowerKey === 'f' && (e.ctrlKey || e.metaKey)) || (!hasModifier && key === '/'))) {
                    e.preventDefault();
                    toggleSearch(true);
                    resetComboBuffer();
                    return;
                }

                // Escape closes overlays / resets buffer / cancels edit mode
                if (key === 'Escape') {
                    if (editingAnnotationIndex !== null) {
                        cancelEditMode();
                        return;
                    }
                    if (searchVisible) {
                        toggleSearch();
                        resetComboBuffer();
                        return;
                    }
                    resetComboBuffer();
                    return;
                }

                if (isInput) {
                    return;
                }

                // Undo and repeat
                if (!hasModifier && (key === 'Backspace' || key === 'Delete')) {
                    e.preventDefault();
                    resetComboBuffer();
                    undoAnnotation();
                    return;
                }

                if (!hasModifier && key === 'Enter') {
                    e.preventDefault();
                    resetComboBuffer();
                    if (lastShot) {
                        addAnnotation(lastShot, false);
                    }
                    return;
                }

                // Frame navigation
                if (!hasModifier && (key === 'ArrowLeft' || key === 'Left')) {
                    e.preventDefault();
                    navigateFrames(-1);
                    return;
                }

                if (!hasModifier && (key === 'ArrowRight' || key === 'Right')) {
                    e.preventDefault();
                    navigateFrames(1);
                    return;
                }

                if (!hasModifier && lowerKey === 'c' && comboBuffer === '') {
                    e.preventDefault();
                    navigateFrames(-10);
                    return;
                }

                if (!hasModifier && lowerKey === 'v' && comboBuffer === '') {
                    e.preventDefault();
                    navigateFrames(10);
                    return;
                }

                if (!hasModifier && (key === 'ArrowUp' || key === 'Up')) {
                    e.preventDefault();
                    jumpToPreviousAnnotation();
                    return;
                }

                if (!hasModifier && (key === 'ArrowDown' || key === 'Down')) {
                    e.preventDefault();
                    jumpToNextAnnotation();
                    return;
                }

                if (!hasModifier && lowerKey === '0' && comboBuffer === '') {
                    e.preventDefault();
                    navigateFrames(400);
                    return;
                }

                // Process combo characters (letters/digits)
                if (!hasModifier && /^[a-z0-9]$/.test(lowerKey)) {
                    e.preventDefault();
                    processComboCharacter(lowerKey);
                    return;
                }
            });

            // Create keyboard legend
            createKeyboardLegend();
            setupSearch();

            // Load saved annotations
            loadAnnotations();
            updateQuickAccess();

            // Initialize technical labels display
            populateTechnicalLabels();
        }

        // Toggle keyboard legend
        function toggleLegend() {
            const legend = document.getElementById('keyboardLegend');
            legendVisible = !legendVisible;
            if (legendVisible) {
                legend.classList.add('show');
            } else {
                legend.classList.remove('show');
            }
        }

        // Create keyboard legend
        function createKeyboardLegend() {
            const content = document.getElementById('legendContent');
            content.innerHTML = '';

            // Control shortcuts
            const controls = [
                { key: 'Space', desc: 'Play/Pause' },
                { key: '‚Üê ‚Üí', desc: 'Frame ¬±1' },
                { key: 'C / V', desc: 'Frame ¬±10' },
                { key: 'Ctrl+F / /', desc: 'Search Shots' },
                { key: 'Ctrl+K', desc: 'Visual Keyboard' },
                { key: 'Ctrl+1-5', desc: 'Category Mode' },
                { key: 'Backspace', desc: 'Undo Last' },
                { key: 'Enter', desc: 'Repeat Last Shot' },
                { key: 'Shift + Key', desc: 'Mark as Cross' },
                { key: 'B', desc: 'Toggle Buttons' },
                { key: '?', desc: 'Toggle Legend' }
            ];

            let html = '<div class="legend-category"><div class="legend-category-title">Controls</div>';
            controls.forEach(control => {
                html += `<div class="legend-item"><span>${control.desc}</span><span class="legend-key">${control.key}</span></div>`;
            });
            html += '</div>';

            // Shot shortcuts by category
            const categories = [
                { name: 'Serves', shots: shotCategories.serves },
                { name: 'Forehand', shots: shotCategories.forehand },
                { name: 'Backhand', shots: shotCategories.backhand },
                { name: 'Overhead', shots: shotCategories.overhead },
                { name: 'Other', shots: shotCategories.other }
            ];

            categories.forEach(category => {
                html += `<div class="legend-category"><div class="legend-category-title">${category.name}</div>`;
                category.shots.forEach(shot => {
                    const shortcut = shotPrimaryCombo.get(shot.name) || '';
                    const shotName = formatShotName(shot.name);
                    if (shortcut) {
                        html += `<div class="legend-item"><span>${shotName}</span><span class="legend-key">${shortcut}</span></div>`;
                    }
                });
                html += '</div>';
            });

            content.innerHTML = html;
        }

        // Format shot name for display
        function formatShotName(name) {
            return name
                .replace(/_/g, ' ')
                .replace(/\b\w/g, l => l.toUpperCase());
        }

        // Get contrast color (black or white)
        function getContrastColor(hexColor) {
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128 ? '#000' : '#fff';
        }

        // Update frame info
        function updateFrameInfo() {
            if (video) {
                const currentTime = video.currentTime;
                const frameNum = Math.floor(currentTime * fps);
                
                document.getElementById('currentTime').textContent = currentTime.toFixed(2);
                document.getElementById('frameNumber').textContent = frameNum;
            }
        }

        // Update FPS display
        function updateFPSDisplay() {
            const display = document.getElementById('fpsDisplay');
            if (display) {
                display.textContent = fps.toFixed(2);
            }
            const fpsInput = document.getElementById('fpsInput');
            if (fpsInput) {
                fpsInput.value = fps;
            }
        }

        // Navigate frames
        function navigateFrames(delta) {
            if (video && video.readyState >= 2) {
                const currentTime = video.currentTime;
                const frameTime = delta * frameRate;
                const newTime = Math.max(0, Math.min(video.duration, currentTime + frameTime));
                video.currentTime = newTime;
                updateFrameInfo();
            }
        }

        // Add annotation
        function addAnnotation(shot, isCross = false) {
            if (!video || video.readyState < 2) {
                alert('Please load a video first!');
                return;
            }

            const timestamp = video.currentTime;
            const frameNumber = Math.floor(timestamp * fps);

            const annotation = {
                id: annotations.length + 1,
                label_id: shot.id,
                label_name: shot.name,
                frame: frameNumber,
                group: null,
                source: 'manual',
                attributes: '',
                timestamp: parseFloat(timestamp.toFixed(2)),
                shot_name: shot.name,
                shot_id: shot.id,
                is_cross: isCross,
                is_technical: false
            };

            annotations.push(annotation);
            lastShot = shot; // Store for repeat
            lastAnnotationFrame = frameNumber; // Track the frame of last annotation
            // Update usage counts
            const currentCount = shotUsageCounts.get(shot.name) || 0;
            shotUsageCounts.set(shot.name, currentCount + 1);
            updateRecentShots(shot);
            saveAnnotations();
            updateAnnotationsDisplay();
            showToast(shot, isCross);
            updateLastAnnotation(shot, isCross);
            updateQuickAccess();
        }
        
        // Function to add cross to an annotation at the current frame
        function addCrossToCurrentFrame() {
            if (!video || video.readyState < 2) {
                return false;
            }
            
            const currentFrame = Math.floor(video.currentTime * fps);
            
            // First, check if there's a match annotation at the current frame (exclude technical)
            let annotationAtFrame = null;
            for (let i = annotations.length - 1; i >= 0; i--) {
                const ann = annotations[i];
                if (ann.frame === currentFrame && !ann.is_technical) {
                    annotationAtFrame = ann;
                    break;
                }
            }
            
            if (annotationAtFrame) {
                // If there's already a tag at this frame, add cross to it
                if (!annotationAtFrame.is_cross) {
                    annotationAtFrame.is_cross = true;
                    saveAnnotations();
                    updateAnnotationsDisplay();
                    rebuildQuickAccessData();
                    showToast({ name: annotationAtFrame.shot_name }, true);
                    return true;
                } else {
                    // Already has cross, remove it
                    annotationAtFrame.is_cross = false;
                    saveAnnotations();
                    updateAnnotationsDisplay();
                    rebuildQuickAccessData();
                    showToast({ name: annotationAtFrame.shot_name }, false);
                    return true;
                }
            }
            
            // If no annotation at current frame, check if we're still on the last match annotation's frame
            if (lastAnnotationFrame !== null && currentFrame === lastAnnotationFrame) {
                // Find the last match annotation and add cross to it
                if (annotations.length > 0) {
                    // Find last match annotation (not technical)
                    let lastAnnotation = null;
                    for (let i = annotations.length - 1; i >= 0; i--) {
                        if (!annotations[i].is_technical) {
                            lastAnnotation = annotations[i];
                            break;
                        }
                    }
                    if (lastAnnotation && lastAnnotation.frame === currentFrame && !lastAnnotation.is_cross) {
                        lastAnnotation.is_cross = true;
                        saveAnnotations();
                        updateAnnotationsDisplay();
                        rebuildQuickAccessData();
                        showToast({ name: lastAnnotation.shot_name }, true);
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Show toast notification
        function showToast(shot, isCross) {
            const toast = document.getElementById('toastNotification');
            const shotName = formatShotName(shot.name);
            if (shot.name === 'Undo') {
                toast.textContent = '‚Ü∂ Undo';
                toast.className = 'toast show';
            } else {
                toast.textContent = isCross ? `‚úì ${shotName} (CROSS)` : `‚úì ${shotName}`;
                toast.className = `toast ${isCross ? 'cross' : ''} show`;
            }
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 1500);
        }

        // Update last annotation indicator
        function updateLastAnnotation(shot, isCross) {
            const indicator = document.getElementById('lastAnnotation');
            const shotName = formatShotName(shot.name);
            indicator.textContent = isCross ? `Last: ${shotName} (CROSS)` : `Last: ${shotName}`;
            indicator.classList.add('show');
            
            setTimeout(() => {
                indicator.classList.remove('show');
            }, 3000);
        }

        // Update quick access panels
        function updateQuickAccess() {
            const recentContainer = document.getElementById('recentShots');
            const favoriteContainer = document.getElementById('favoriteShots');
            const recentCount = document.getElementById('recentCount');
            const favoriteCount = document.getElementById('favoriteCount');

            // Recent shots
            if (recentShotsList.length === 0) {
                recentContainer.innerHTML = '<span class="quick-empty">No recent shots yet.</span>';
                recentCount.textContent = '';
            } else {
                recentContainer.innerHTML = '';
                recentShotsList.forEach(entry => {
                    const btn = document.createElement('button');
                    btn.className = 'quick-button';
                    btn.style.borderColor = entry.shot.color;
                    btn.style.background = hexToRgba(entry.shot.color, 0.2);
                    btn.innerHTML = `
                        <span class="quick-shot">${formatShotName(entry.shot.name)}</span>
                        <span class="quick-shortcut">${entry.combo || '-'}</span>
                    `;
                    btn.onclick = () => {
                        const combo = entry.combo || formatShotName(entry.shot.name);
                        commitCombo(entry.shot, false, combo);
                    };
                    recentContainer.appendChild(btn);
                });
                recentCount.textContent = `${recentShotsList.length}`;
            }

            // Favorite shots (top usage)
            const usageArray = Array.from(shotUsageCounts.entries())
                .filter(([, count]) => count > 0)
                .sort((a, b) => b[1] - a[1])
                .slice(0, FAVORITE_LIMIT);

            if (usageArray.length === 0) {
                favoriteContainer.innerHTML = '<span class="quick-empty">Annotations will populate favorites.</span>';
                favoriteCount.textContent = '';
            } else {
                favoriteContainer.innerHTML = '';
                usageArray.forEach(([shotName, count]) => {
                    const shot = allShots.find(s => s.name === shotName);
                    const combo = shotPrimaryCombo.get(shotName) || '';
                    const btn = document.createElement('button');
                    btn.className = 'quick-button';
                    btn.style.borderColor = shot.color;
                    btn.style.background = hexToRgba(shot.color, 0.2);
                    btn.innerHTML = `
                        <span class="quick-shot">${formatShotName(shot.name)}</span>
                        <span class="quick-shortcut">${combo || '-'}</span>
                        <span class="quick-count-pill">${count}</span>
                    `;
                    btn.onclick = () => {
                        const displayCombo = combo || formatShotName(shot.name);
                        commitCombo(shot, false, displayCombo);
                    };
                    favoriteContainer.appendChild(btn);
                });
                favoriteCount.textContent = `${usageArray.length}`;
            }
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.substr(1, 2), 16);
            const g = parseInt(hex.substr(3, 2), 16);
            const b = parseInt(hex.substr(5, 2), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function handleFrameSearchSubmit(event) {
            event.preventDefault();
            const input = document.getElementById('frameSearchInput');
            if (!input) return;
            const frameValue = Number(input.value);
            if (Number.isNaN(frameValue) || frameValue < 0) {
                alert('Please enter a valid non-negative frame number.');
                return;
            }
            jumpToFrame(frameValue);
        }

        function jumpToFrame(frameNumber) {
            if (!video || video.readyState < 2) {
                alert('Please load a video first!');
                return;
            }
            const effectiveFps = fps || 30;
            const targetTime = frameNumber / effectiveFps;
            video.currentTime = Math.min(Math.max(targetTime, 0), video.duration || targetTime);
            video.pause();
            updateFrameInfo();
            resetComboBuffer();
        }

        function jumpToPreviousAnnotation() {
            if (!video || annotations.length === 0) return;
            const currentTime = video.currentTime || 0;
            const tolerance = 0.0001;
            let target = null;
            for (let i = annotations.length - 1; i >= 0; i -= 1) {
                if (annotations[i].timestamp < currentTime - tolerance) {
                    target = annotations[i];
                    break;
                }
            }
            if (!target) {
                target = annotations[annotations.length - 1];
            }
            goToAnnotation(target);
        }

        function jumpToNextAnnotation() {
            if (!video || annotations.length === 0) return;
            const currentTime = video.currentTime || 0;
            const tolerance = 0.0001;
            let target = null;
            for (let i = 0; i < annotations.length; i += 1) {
                if (annotations[i].timestamp > currentTime + tolerance) {
                    target = annotations[i];
                    break;
                }
            }
            if (!target) {
                target = annotations[0];
            }
            goToAnnotation(target);
        }

        function goToAnnotation(annotation) {
            if (!annotation) return;
            if (!video || video.readyState < 1) {
                alert('Please load a video before navigating annotations.');
                return;
            }
            video.currentTime = annotation.timestamp;
            video.pause();
            updateFrameInfo();
            const shot = shotLookup.get(annotation.shot_name) || { name: annotation.shot_name };
            setComboDisplay(shotPrimaryCombo.get(annotation.shot_name) || annotation.shot_name, 'status-success');
            showToast(shot, annotation.is_cross);
        }

        function updateRecentShots(shot) {
            const combo = shotPrimaryCombo.get(shot.name) || '';
            recentShotsList = recentShotsList.filter(entry => entry.shot.name !== shot.name);
            recentShotsList.unshift({ shot, combo });
            if (recentShotsList.length > RECENT_LIMIT) {
                recentShotsList = recentShotsList.slice(0, RECENT_LIMIT);
            }
        }

        function rebuildQuickAccessData() {
            recentShotsList = [];
            allShots.forEach(shot => shotUsageCounts.set(shot.name, 0));

            annotations.forEach(ann => {
                const shot = allShots.find(s => s.name === ann.shot_name);
                if (shot) {
                    const currentCount = shotUsageCounts.get(shot.name) || 0;
                    shotUsageCounts.set(shot.name, currentCount + 1);
                    updateRecentShots(shot);
                }
            });

            if (annotations.length > 0) {
                const lastAnn = annotations[annotations.length - 1];
                lastShot = allShots.find(s => s.name === lastAnn.shot_name) || null;
            } else {
                lastShot = null;
            }

            updateQuickAccess();
        }

        function toggleSearch(focusInput = false) {
            resetComboBuffer();
            const searchBar = document.getElementById('searchBar');
            const searchInput = document.getElementById('searchInput');
            if (!searchVisible) {
                searchVisible = true;
                searchBar.classList.add('show');
                if (focusInput) {
                    setTimeout(() => searchInput.focus(), 0);
                }
            } else {
                searchVisible = false;
                searchBar.classList.remove('show');
                searchInput.value = '';
                document.getElementById('searchResults').innerHTML = '';
            }
        }

        function setupSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');

            searchInput.addEventListener('input', function(e) {
                const query = e.target.value.toLowerCase().trim();
                if (query.length === 0) {
                    searchResults.innerHTML = '';
                    return;
                }

                const matches = allShots.filter(shot => {
                    const displayName = formatShotName(shot.name).toLowerCase();
                    return shot.name.toLowerCase().includes(query) || displayName.includes(query);
                });

                if (matches.length === 0) {
                    searchResults.innerHTML = '<div class="search-result-item" style="color:#7f8c8d;">No matches found</div>';
                    return;
                }

                let html = '';
                matches.forEach(shot => {
                    const shortcut = shotPrimaryCombo.get(shot.name) || '';
                    html += `
                        <div class="search-result-item" onclick="selectShotFromSearch('${shot.name}')">
                            <span class="shot-name">${formatShotName(shot.name)}</span>
                            <span class="shot-key">${shortcut || '-'}</span>
                        </div>
                    `;
                });
                searchResults.innerHTML = html;
            });

            searchInput.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    toggleSearch();
                } else if (e.key === 'Enter') {
                    const first = searchResults.querySelector('.search-result-item');
                    if (first && !first.textContent.includes('No matches')) {
                        first.click();
                    }
                }
            });
        }

        function selectShotFromSearch(shotName) {
            const shot = allShots.find(s => s.name === shotName);
            if (shot) {
                const combo = shotPrimaryCombo.get(shot.name) || shot.name;
                toggleSearch();
                commitCombo(shot, false, combo);
            }
        }

        function handleFpsSubmit(event) {
            event.preventDefault();
            const input = document.getElementById('fpsInput');
            if (!input) return;
            const value = parseFloat(input.value);
            if (Number.isNaN(value) || value <= 0) {
                alert('Please enter a valid FPS value greater than 0.');
                return;
            }
            applyFps(value);
        }

        function applyFps(newFps) {
            fps = newFps;
            frameRate = 1 / fps;
            updateFPSDisplay();
            recalculateAnnotationFrames();
            updateFrameInfo();
        }

        function recalculateAnnotationFrames() {
            const effectiveFps = fps || 30;
            annotations.forEach(ann => {
                ann.frame = Math.round(ann.timestamp * effectiveFps);
            });
            saveAnnotations();
            updateAnnotationsDisplay();
            updateQuickAccess();
        }

        function handleCsvImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                importAnnotationsFromCsv(e.target.result);
            };
            reader.onerror = () => {
                alert('Unable to read the CSV file.');
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function importAnnotationsFromCsv(csvText) {
            if (!csvText) {
                alert('CSV file is empty.');
                return;
            }
            const lines = csvText.trim().split(/\r?\n/);
            if (lines.length <= 1) {
                alert('CSV does not contain any annotation rows.');
                return;
            }
            const headers = lines[0].split(',').map((h) => h.trim().toLowerCase());
            
            // Check if it's new format (id,label_id,label_name,frame,group,source,attributes)
            const isNewFormat = headers.includes('label_id') && headers.includes('label_name');
            
            const imported = [];
            const effectiveFps = fps || 30;
            
            if (isNewFormat) {
                // New format: id,label_id,label_name,frame,group,source,attributes
                const indexMap = {
                    label_id: headers.indexOf('label_id'),
                    label_name: headers.indexOf('label_name'),
                    frame: headers.indexOf('frame')
                };
                
                if (indexMap.label_id === -1 || indexMap.label_name === -1 || indexMap.frame === -1) {
                    alert('CSV must include label_id, label_name, and frame columns.');
                    return;
                }
                
                for (let i = 1; i < lines.length; i += 1) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    const cols = line.split(',').map((c) => c.trim());
                    const labelId = parseInt(cols[indexMap.label_id], 10);
                    const labelName = cols[indexMap.label_name];
                    const frameValue = parseInt(cols[indexMap.frame], 10);
                    
                    if (Number.isNaN(labelId) || Number.isNaN(frameValue) || !labelName) {
                        continue;
                    }
                    
                    // Check if it's a technical label (ID >= 400)
                    const isTechnical = labelId >= 400;
                    
                    if (isTechnical) {
                        // Technical label
                        const timestamp = frameValue / effectiveFps;
                        imported.push({
                            id: imported.length + 1,
                            label_id: labelId,
                            label_name: labelName,
                            frame: frameValue,
                            group: null,
                            source: 'manual',
                            attributes: '',
                            timestamp: parseFloat(timestamp.toFixed(2)),
                            shot_name: labelName,
                            shot_id: labelId,
                            is_cross: false,
                            is_technical: true
                        });
                    } else {
                        // Match label - check if it exists in shotLookup
                        if (shotLookup.has(labelName)) {
                            const shot = shotLookup.get(labelName);
                            const timestamp = frameValue / effectiveFps;
                            imported.push({
                                id: imported.length + 1,
                                label_id: labelId,
                                label_name: labelName,
                                frame: frameValue,
                                group: null,
                                source: 'manual',
                                attributes: '',
                                timestamp: parseFloat(timestamp.toFixed(2)),
                                shot_name: shot.name,
                                shot_id: shot.id,
                                is_cross: false,
                                is_technical: false
                            });
                        }
                    }
                }
            } else {
                // Old format: timestamp,frame,shot_name,shot_id,is_cross
                const indexMap = {
                    timestamp: headers.indexOf('timestamp'),
                    frame: headers.indexOf('frame'),
                    shot_name: headers.indexOf('shot_name'),
                    shot_id: headers.indexOf('shot_id'),
                    is_cross: headers.indexOf('is_cross')
                };
                
                if (indexMap.timestamp === -1 || indexMap.shot_name === -1) {
                    alert('CSV must include at least timestamp and shot_name columns.');
                    return;
                }
                
                for (let i = 1; i < lines.length; i += 1) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    const cols = line.split(',').map((c) => c.trim());
                    const timestamp = parseFloat(cols[indexMap.timestamp]);
                    const shotName = cols[indexMap.shot_name];
                    if (Number.isNaN(timestamp) || !shotLookup.has(shotName)) {
                        continue;
                    }
                    const frameValue = indexMap.frame !== -1 ? parseInt(cols[indexMap.frame], 10) : Math.round(timestamp * effectiveFps);
                    const shot = shotLookup.get(shotName);
                    const isCross = indexMap.is_cross !== -1 ? cols[indexMap.is_cross].toLowerCase() === 'true' : false;
                    imported.push({
                        id: imported.length + 1,
                        label_id: shot.id,
                        label_name: shot.name,
                        frame: Number.isNaN(frameValue) ? Math.round(timestamp * effectiveFps) : frameValue,
                        group: null,
                        source: 'manual',
                        attributes: '',
                        timestamp: parseFloat(timestamp.toFixed(2)),
                        shot_name: shot.name,
                        shot_id: shot.id,
                        is_cross: isCross,
                        is_technical: false
                    });
                }
            }
            
            if (imported.length === 0) {
                alert('No valid annotations found in the CSV.');
                return;
            }
            imported.sort((a, b) => a.timestamp - b.timestamp);
            annotations = imported;
            saveAnnotations();
            updateAnnotationsDisplay();
            if (isTechnicalMode) {
                updateTaggedTechnicalLabels();
            }
            rebuildQuickAccessData();
            if (video && video.readyState >= 1 && annotations.length > 0) {
                video.currentTime = annotations[0].timestamp;
                video.pause();
                updateFrameInfo();
            }
            showToast({ name: 'import_complete' }, false);
        }

        // Undo last annotation
        function undoAnnotation() {
            resetComboBuffer();
            if (annotations.length > 0) {
                annotations.pop();
                if (annotations.length > 0) {
                    const lastAnn = annotations[annotations.length - 1];
                    lastShot = allShots.find(s => s.name === lastAnn.shot_name) || null;
                } else {
                    lastShot = null;
                }
                rebuildQuickAccessData();
                saveAnnotations();
                updateAnnotationsDisplay();
                showToast({ name: 'Undo' }, false);
            }
        }

        // Clear all annotations
        function clearAll() {
            if (confirm('Are you sure you want to clear all annotations?')) {
                resetComboBuffer();
                editingAnnotationIndex = null; // Cancel edit mode
                annotations = [];
                lastShot = null;
                recentShotsList = [];
                allShots.forEach(shot => shotUsageCounts.set(shot.name, 0));
                rebuildQuickAccessData();
                saveAnnotations();
                updateAnnotationsDisplay();
            }
        }

        // Update annotations display
        function updateAnnotationsDisplay() {
            const detailContainer = document.getElementById('annotationsContainer');
            const listContainer = document.getElementById('annotationsList');
            
            // Filter annotations: only show match annotations (not technical)
            const matchAnnotations = annotations.filter(ann => !ann.is_technical);
            document.getElementById('totalCount').textContent = matchAnnotations.length;

            if (matchAnnotations.length === 0) {
                const emptyHtml = '<div class="empty-state">No annotations yet. Type the shot combos (e.g., fs, bd, hs) to add annotations.</div>';
                if (detailContainer) detailContainer.innerHTML = emptyHtml;
                if (listContainer) listContainer.innerHTML = '<div class="empty-state">No annotations yet. Type combos to start tagging.</div>';
                return;
            }

            let listHtml = '';
            let tableHtml = '<table class="annotations-table"><thead><tr><th>Timestamp</th><th>Frame</th><th>Shot</th><th>ID</th><th>Cross</th><th>Action</th></tr></thead><tbody>';

            matchAnnotations.forEach((ann) => {
                // Find original index in annotations array
                const index = annotations.findIndex(a => a === ann);
                const shotLabel = formatShotName(ann.shot_name);
                const crossBadge = ann.is_cross ? '<span class="cross-indicator">CROSS</span>' : '';
                const crossTag = ann.is_cross ? '<span class="tag-cross">X</span>' : '';
                const isLast = index === annotations.length - 1;
                const isEditing = editingAnnotationIndex === index;
                const editStyle = isEditing ? ' style="background: #fff3cd; border: 2px solid #ffc107;"' : '';
                const editRowStyle = isEditing ? ' style="background: #fff3cd !important; border: 2px solid #ffc107;"' : (isLast ? ' style="background: #d4edda;"' : '');

                tableHtml += `
                    <tr onclick="jumpToTime(${ann.timestamp})"${editRowStyle}>
                        <td>${ann.timestamp}s</td>
                        <td>${ann.frame}</td>
                        <td>${shotLabel}${crossBadge}${isEditing ? ' <span style="color: #ffc107; font-weight: bold;">[EDITING]</span>' : ''}</td>
                        <td>${ann.shot_id}</td>
                        <td>${ann.is_cross ? 'Yes' : 'No'}</td>
                        <td>
                            <button class="delete-btn" onclick="editAnnotation(${index}); event.stopPropagation();" style="background: ${isEditing ? '#ffc107' : '#3498db'}; margin-right: 5px;">${isEditing ? 'Cancel' : 'Edit'}</button>
                            <button class="delete-btn" onclick="deleteAnnotation(${index}); event.stopPropagation();">Delete</button>
                        </td>
                    </tr>
                `;

                listHtml += `
                    <div class="tag-item ${isLast ? 'active' : ''}${isEditing ? ' style="background: #fff3cd; border-left-color: #ffc107; border-left-width: 6px;"' : ''}" onclick="jumpToTime(${ann.timestamp}); event.stopPropagation();">
                        <span class="tag-shot">${shotLabel}${crossTag}${isEditing ? ' <span style="color: #ffc107; font-weight: bold;">[EDITING]</span>' : ''}</span>
                        <div style="display: flex; gap: 5px;">
                            <button class="tag-delete" onclick="editAnnotation(${index}); event.stopPropagation();" style="background: ${isEditing ? '#ffc107' : '#3498db'}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">${isEditing ? 'Cancel' : 'Edit'}</button>
                            <button class="tag-delete" onclick="deleteAnnotation(${index}); event.stopPropagation();">&times;</button>
                        </div>
                    </div>
                `;
            });

            tableHtml += '</tbody></table>';
            if (detailContainer) {
                detailContainer.innerHTML = tableHtml;
            }
            if (listContainer) {
                listContainer.innerHTML = listHtml;
            }
        }

        // Jump to timestamp
        function jumpToTime(timestamp) {
            if (video && video.readyState >= 2) {
                video.currentTime = timestamp;
                video.pause();
                updateFrameInfo();
            }
        }

        // Delete annotation
        function deleteAnnotation(index) {
            // Store the frame/timestamp before deletion to keep video at that position
            const deletedAnnotation = annotations[index];
            const deletedFrame = deletedAnnotation.frame;
            const deletedTimestamp = deletedAnnotation.timestamp;
            
            // Cancel edit mode if we're editing this annotation
            if (editingAnnotationIndex === index) {
                editingAnnotationIndex = null;
            } else if (editingAnnotationIndex !== null && editingAnnotationIndex > index) {
                // Adjust edit index if we're editing a later annotation
                editingAnnotationIndex -= 1;
            }
            
            annotations.splice(index, 1);
            saveAnnotations();
            updateAnnotationsDisplay();
            rebuildQuickAccessData();
            
            // Keep video at the deleted tag's frame so user can add a new tag
            if (video && video.readyState >= 2) {
                video.currentTime = deletedTimestamp;
                video.pause();
                updateFrameInfo();
            }
        }
        
        // Edit annotation - enter edit mode for this tag
        function editAnnotation(index) {
            const annotation = annotations[index];
            if (!annotation) return;
            
            // If already editing this annotation, cancel edit mode
            if (editingAnnotationIndex === index) {
                cancelEditMode();
                return;
            }
            
            // Handle technical annotations differently
            if (annotation.is_technical) {
                editTechnicalAnnotation(index);
                return;
            }
            
            // Navigate to the annotation's frame
            if (video && video.readyState >= 2) {
                video.currentTime = annotation.timestamp;
                video.pause();
                updateFrameInfo();
            }
            
            // Enter edit mode
            editingAnnotationIndex = index;
            resetComboBuffer();
            
            // Show visual feedback that we're in edit mode
            setComboDisplay('EDIT MODE - Type combo to change tag', 'status-pending');
            showToast({ name: 'Edit Mode' }, false);
            
            // Update display to highlight the tag being edited
            updateAnnotationsDisplay();
        }
        
        // Cancel edit mode
        function cancelEditMode() {
            if (editingAnnotationIndex !== null) {
                editingAnnotationIndex = null;
                resetComboBuffer();
                updateAnnotationsDisplay();
                if (isTechnicalMode) {
                    updateTaggedTechnicalLabels();
                }
            }
        }

        // Export CSV
        function exportCSV() {
            if (annotations.length === 0) {
                alert('No annotations to export!');
                return;
            }

            // Generate CSV with the required format: id,label_id,label_name,frame,group,source,attributes
            let csv = 'id,label_id,label_name,frame,group,source,attributes\n';
            annotations.forEach((ann, index) => {
                const id = index + 1; // Sequential ID starting from 1
                const labelId = ann.shot_id;
                const labelName = ann.shot_name;
                const frame = ann.frame;
                const group = 0;
                const source = 'manual';
                const attributes = '[]';
                
                csv += `${id},${labelId},${labelName},${frame},${group},${source},${attributes}\n`;
            });

            // Generate filename: {video_name}_tags.csv
            let filename = 'annotations_tags.csv'; // Default if no video loaded
            if (videoFileName) {
                // Keep the full video filename and append _tags.csv
                filename = `${videoFileName}_tags.csv`;
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Export JSON
        function exportJSON() {
            if (annotations.length === 0) {
                alert('No annotations to export!');
                return;
            }

            const json = JSON.stringify(annotations, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'annotations.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function setComboDisplay(text, status = 'status-default') {
            if (!comboDisplayEl) {
                comboDisplayEl = document.getElementById('comboDisplay');
            }
            if (!comboDisplayEl) {
                return;
            }
            comboDisplayEl.classList.remove('status-default', 'status-pending', 'status-error', 'status-success');
            comboDisplayEl.textContent = text;
            if (status) {
                comboDisplayEl.classList.add(status);
            }
        }

        function clearComboState() {
            comboBuffer = '';
            if (comboTimer) {
                clearTimeout(comboTimer);
                comboTimer = null;
            }
            if (pendingTimer) {
                clearTimeout(pendingTimer);
                pendingTimer = null;
            }
            if (comboErrorTimeout) {
                clearTimeout(comboErrorTimeout);
                comboErrorTimeout = null;
            }
            pendingShot = null;
        }

        function resetComboBuffer() {
            clearComboState();
            if (comboSuccessTimeout) {
                clearTimeout(comboSuccessTimeout);
                comboSuccessTimeout = null;
            }
            // Don't reset edit mode display if we're editing
            if (editingAnnotationIndex === null) {
                setComboDisplay('-', 'status-default');
            }
        }

        function setPendingShot(shot, combo) {
            pendingShot = { shot, combo };
            if (pendingTimer) {
                clearTimeout(pendingTimer);
            }
            pendingTimer = setTimeout(() => {
                commitCombo(shot, false, combo);
            }, PENDING_COMMIT_TIMEOUT);
            setComboDisplay(combo, 'status-pending');
        }

        function commitCombo(shot, isCross, comboText) {
            clearComboState();
            
            // Check if we're in edit mode
            if (editingAnnotationIndex !== null) {
                // Update existing annotation instead of creating new one
                const annotation = annotations[editingAnnotationIndex];
                if (annotation) {
                    annotation.shot_name = shot.name;
                    annotation.shot_id = shot.id;
                    annotation.label_id = shot.id;
                    annotation.label_name = shot.name;
                    annotation.is_cross = isCross;
                    
                    // Recalculate frame in case FPS changed
                    annotation.frame = Math.floor(annotation.timestamp * fps);
                    
                    saveAnnotations();
                    updateAnnotationsDisplay();
                    rebuildQuickAccessData();
                    
                    const display = isCross ? `${comboText}` : comboText;
                    setComboDisplay(display, 'status-success');
                    showToast(shot, isCross);
                    
                    // Exit edit mode
                    editingAnnotationIndex = null;
                    
                    if (comboSuccessTimeout) {
                        clearTimeout(comboSuccessTimeout);
                    }
                    comboSuccessTimeout = setTimeout(() => {
                        setComboDisplay('-', 'status-default');
                        comboSuccessTimeout = null;
                    }, 800);
                    return;
                }
            }
            
            // Normal flow - add new annotation
            const display = isCross ? `${comboText}` : comboText;
            setComboDisplay(display, 'status-success');
            if (comboSuccessTimeout) {
                clearTimeout(comboSuccessTimeout);
            }
            comboSuccessTimeout = setTimeout(() => {
                setComboDisplay('-', 'status-default');
                comboSuccessTimeout = null;
            }, 800);
            if (video && !video.paused) {
                video.pause();
            }
            addAnnotation(shot, isCross);
        }

        function processComboCharacter(char) {
            if (comboSuccessTimeout) {
                clearTimeout(comboSuccessTimeout);
                comboSuccessTimeout = null;
            }

            if (pendingShot && char !== 'x') {
                if (pendingTimer) {
                    clearTimeout(pendingTimer);
                    pendingTimer = null;
                }
                pendingShot = null;
            }

            // Handle technical mode combos
            if (isTechnicalMode) {
                // Technical labels use uppercase abbreviations
                comboBuffer += char.toUpperCase();
                
                if (comboTimer) {
                    clearTimeout(comboTimer);
                }
                comboTimer = setTimeout(() => {
                    resetComboBuffer();
                }, COMBO_BUFFER_TIMEOUT);
                
                // Check if we have a complete technical label combo
                if (technicalComboToLabel.has(comboBuffer)) {
                    const label = technicalComboToLabel.get(comboBuffer);
                    commitTechnicalCombo(label, comboBuffer);
                    return;
                }
                
                // Check if it's a valid prefix (for autocomplete feedback)
                if (technicalComboPrefixes.has(comboBuffer)) {
                    setComboDisplay(comboBuffer, 'status-pending');
                } else {
                    // Invalid combo
                    setComboDisplay(comboBuffer, 'status-error');
                    comboErrorTimeout = setTimeout(() => {
                        resetComboBuffer();
                    }, 400);
                }
                return;
            }

            // Match mode: use lowercase
            comboBuffer += char;

            // Match mode processing continues below...

            // Handle "xx" to add cross to existing tag
            if (comboBuffer === 'xx') {
                // If in edit mode, toggle cross on the annotation being edited
                if (editingAnnotationIndex !== null) {
                    const annotation = annotations[editingAnnotationIndex];
                    if (annotation) {
                        annotation.is_cross = !annotation.is_cross;
                        saveAnnotations();
                        updateAnnotationsDisplay();
                        rebuildQuickAccessData();
                        showToast({ name: annotation.shot_name }, annotation.is_cross);
                        editingAnnotationIndex = null; // Exit edit mode
                        resetComboBuffer();
                        return;
                    }
                }
                
                // Normal flow - add cross to tag at current frame
                if (addCrossToCurrentFrame()) {
                    resetComboBuffer();
                    return;
                } else {
                    // No tag found to add cross to
                    setComboDisplay('xx', 'status-error');
                    comboErrorTimeout = setTimeout(() => {
                        resetComboBuffer();
                    }, 400);
                    return;
                }
            }

            // Handle single 'x' suffix (e.g., "bnkx")
            if (comboBuffer.endsWith('x') && comboBuffer.length > 1 && comboBuffer !== 'xx') {
                const baseCombo = comboBuffer.slice(0, -1);
                if (comboToShot.has(baseCombo)) {
                    const shot = comboToShot.get(baseCombo);
                    commitCombo(shot, true, `${baseCombo}x`);
                    return;
                }
            }

            if (comboToShot.has(comboBuffer)) {
                const shot = comboToShot.get(comboBuffer);
                setPendingShot(shot, comboBuffer);
                return;
            }

            if (comboPrefixes.has(comboBuffer)) {
                setComboDisplay(comboBuffer, 'status-pending');
                return;
            }

            if (comboErrorTimeout) {
                clearTimeout(comboErrorTimeout);
            }
            setComboDisplay(comboBuffer, 'status-error');
            comboErrorTimeout = setTimeout(() => {
                resetComboBuffer();
            }, 400);
        }

        // Show Info Modal
        function showInfoModal() {
            const modal = document.getElementById('infoModal');
            const body = document.getElementById('infoModalBody');
            
            if (!video || video.readyState < 2) {
                body.innerHTML = '<p style="color: #e74c3c;">Please load a video first to see information.</p>';
                modal.classList.add('show');
                return;
            }
            
            // Calculate total frames
            const totalFrames = video.duration ? Math.floor(video.duration * fps) : 0;
            
            // Calculate label counts
            const labelCounts = new Map();
            annotations.forEach(ann => {
                const labelName = ann.shot_name;
                const currentCount = labelCounts.get(labelName) || 0;
                labelCounts.set(labelName, currentCount + 1);
            });
            
            // Sort labels by count (descending)
            const sortedLabels = Array.from(labelCounts.entries())
                .sort((a, b) => b[1] - a[1]);
            
            // Build HTML
            let html = '';
            
            // Video Info Section
            html += '<div class="info-section">';
            html += '<h3>üìπ Video Information</h3>';
            html += '<div class="info-item"><span class="info-label">Total Frames:</span><span class="info-value">' + totalFrames.toLocaleString() + '</span></div>';
            html += '<div class="info-item"><span class="info-label">FPS:</span><span class="info-value">' + fps.toFixed(2) + '</span></div>';
            html += '<div class="info-item"><span class="info-label">Duration:</span><span class="info-value">' + (video.duration ? video.duration.toFixed(2) + 's' : 'N/A') + '</span></div>';
            html += '<div class="info-item"><span class="info-label">Total Annotations:</span><span class="info-value">' + annotations.length + '</span></div>';
            html += '</div>';
            
            // Label Statistics Section
            html += '<div class="info-section">';
            html += '<h3>üè∑Ô∏è Label Statistics</h3>';
            if (sortedLabels.length === 0) {
                html += '<p style="color: #7f8c8d; font-style: italic;">No annotations yet.</p>';
            } else {
                html += '<div class="label-stats">';
                sortedLabels.forEach(([labelName, count]) => {
                    const formattedName = formatShotName(labelName);
                    html += '<div class="label-stat-item">';
                    html += '<span class="label-name">' + formattedName + '</span>';
                    html += '<span class="label-count">' + count + '</span>';
                    html += '</div>';
                });
                html += '</div>';
            }
            html += '</div>';
            
            body.innerHTML = html;
            modal.classList.add('show');
        }
        
        // Close Info Modal
        function closeInfoModal() {
            const modal = document.getElementById('infoModal');
            modal.classList.remove('show');
        }

        // Show Court Help Modal
        function showCourtHelpModal() {
            const modal = document.getElementById('courtHelpModal');
            modal.classList.add('show');
        }

        // Close Court Help Modal
        function closeCourtHelpModal() {
            const modal = document.getElementById('courtHelpModal');
            modal.classList.remove('show');
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const infoModal = document.getElementById('infoModal');
            const courtHelpModal = document.getElementById('courtHelpModal');
            if (event.target === infoModal) {
                closeInfoModal();
            }
            if (event.target === courtHelpModal) {
                closeCourtHelpModal();
            }
        }

        // ========== TECHNICAL ANALYSIS MODE FUNCTIONS ==========
        
        // Switch between Match and Technical modes
        function switchMode() {
            const matchPanel = document.getElementById('matchModePanel');
            const technicalPanel = document.getElementById('technicalModePanel');
            
            if (isTechnicalMode) {
                matchPanel.style.display = 'none';
                technicalPanel.style.display = 'block';
                populateTechnicalLabels();
                updateTaggedTechnicalLabels();
            } else {
                matchPanel.style.display = 'block';
                technicalPanel.style.display = 'none';
                updateAnnotationsDisplay();
            }
        }

        // Populate technical labels grid
        function populateTechnicalLabels() {
            const container = document.getElementById('technicalLabelsList');
            if (!container) return;

            let html = '';
            technicalLabels.forEach(label => {
                html += `
                    <div class="technical-label-item" onclick="tagTechnicalLabel('${label.abbreviation}')">
                        <div class="technical-label-abbr">${label.abbreviation}</div>
                        <div class="technical-label-desc">${label.description}</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        // Commit technical label combo (from keyboard)
        function commitTechnicalCombo(label, comboText) {
            clearComboState();
            
            if (!video || video.readyState < 2) {
                showToast({ name: label.abbreviation }, false, 'Please load a video first');
                resetComboBuffer();
                return;
            }

            const currentTime = video.currentTime;
            const currentFrame = Math.floor(currentTime * fps);

            // Check if we're editing an existing technical annotation
            if (editingAnnotationIndex !== null) {
                const annotation = annotations[editingAnnotationIndex];
                if (annotation && annotation.is_technical) {
                    // Update existing technical annotation
                    annotation.label_id = label.id;
                    annotation.label_name = label.abbreviation;
                    annotation.shot_name = label.abbreviation;
                    annotation.shot_id = label.id;
                    annotation.is_cross = false; // No cross for technical
                    saveAnnotations();
                    updateTaggedTechnicalLabels();
                    cancelEditMode();
                    
                    setComboDisplay(comboText, 'status-success');
                    showToast({ name: label.abbreviation }, false, 'Updated');
                    if (comboSuccessTimeout) {
                        clearTimeout(comboSuccessTimeout);
                    }
                    comboSuccessTimeout = setTimeout(() => {
                        setComboDisplay('-', 'status-default');
                        comboSuccessTimeout = null;
                    }, 800);
                    return;
                }
            }

            // Create new technical annotation
            const annotation = {
                id: annotations.length + 1,
                label_id: label.id,
                label_name: label.abbreviation,
                frame: currentFrame,
                group: null,
                source: 'manual',
                attributes: '',
                timestamp: currentTime,
                shot_name: label.abbreviation,
                shot_id: label.id,
                is_cross: false,
                is_technical: true
            };

            annotations.push(annotation);
            saveAnnotations();
            updateTaggedTechnicalLabels();
            
            setComboDisplay(comboText, 'status-success');
            showToast({ name: label.abbreviation }, false, 'Tagged');
            if (comboSuccessTimeout) {
                clearTimeout(comboSuccessTimeout);
            }
            comboSuccessTimeout = setTimeout(() => {
                setComboDisplay('-', 'status-default');
                comboSuccessTimeout = null;
            }, 800);
            
            if (video && !video.paused) {
                video.pause();
            }
        }

        // Tag a technical label at current frame (from click)
        function tagTechnicalLabel(abbreviation) {
            if (!video || video.readyState < 2) {
                showToast({ name: abbreviation }, false, 'Please load a video first');
                return;
            }

            const label = technicalLabelLookup.get(abbreviation);
            if (!label) {
                console.error('Technical label not found:', abbreviation);
                return;
            }

            const currentTime = video.currentTime;
            const currentFrame = Math.floor(currentTime * fps);

            // Check if we're editing an existing technical annotation
            if (editingAnnotationIndex !== null) {
                const annotation = annotations[editingAnnotationIndex];
                if (annotation && annotation.is_technical) {
                    // Update existing technical annotation
                    annotation.label_id = label.id;
                    annotation.label_name = label.abbreviation;
                    annotation.shot_name = label.abbreviation;
                    annotation.shot_id = label.id;
                    annotation.is_cross = false; // No cross for technical
                    saveAnnotations();
                    updateTaggedTechnicalLabels();
                    cancelEditMode();
                    showToast({ name: label.abbreviation }, false, 'Updated');
                    return;
                }
            }

            // Create new technical annotation
            const annotation = {
                id: annotations.length + 1,
                label_id: label.id,
                label_name: label.abbreviation,
                frame: currentFrame,
                group: null,
                source: 'manual',
                attributes: '',
                timestamp: currentTime,
                shot_name: label.abbreviation,
                shot_id: label.id,
                is_cross: false,
                is_technical: true
            };

            annotations.push(annotation);
            saveAnnotations();
            updateTaggedTechnicalLabels();
            showToast({ name: label.abbreviation }, false, 'Tagged');
        }

        // Update tagged technical labels display
        function updateTaggedTechnicalLabels() {
            const container = document.getElementById('taggedTechnicalList');
            const countElement = document.getElementById('taggedTechnicalCount');
            if (!container) return;

            // Filter only technical annotations
            const technicalAnnotations = annotations.filter(ann => ann.is_technical);

            if (countElement) {
                countElement.textContent = `(${technicalAnnotations.length})`;
            }

            if (technicalAnnotations.length === 0) {
                container.innerHTML = '<div class="empty-state">No technical labels tagged yet.</div>';
                return;
            }

            let html = '';
            technicalAnnotations.forEach((ann, index) => {
                // Find the original index in annotations array
                const originalIndex = annotations.findIndex(a => a === ann);
                const isEditing = editingAnnotationIndex === originalIndex;
                const editClass = isEditing ? ' editing' : '';

                html += `
                    <div class="tagged-technical-item${editClass}" onclick="jumpToTime(${ann.timestamp})">
                        <div class="tagged-technical-info">
                            <div class="tagged-technical-label">${ann.label_name}</div>
                            <div class="tagged-technical-meta">Frame ${ann.frame} ‚Ä¢ ${ann.timestamp.toFixed(2)}s</div>
                        </div>
                        <div class="tagged-technical-actions" onclick="event.stopPropagation();">
                            <button class="tagged-technical-edit-btn" onclick="editTechnicalAnnotation(${originalIndex})">
                                ${isEditing ? 'Cancel' : 'Edit'}
                            </button>
                            <button class="tagged-technical-delete-btn" onclick="deleteTechnicalAnnotation(${originalIndex})">
                                Delete
                            </button>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        // Edit technical annotation
        function editTechnicalAnnotation(index) {
            const annotation = annotations[index];
            if (!annotation || !annotation.is_technical) return;

            if (editingAnnotationIndex === index) {
                // Cancel edit mode
                cancelEditMode();
            } else {
                // Enter edit mode
                editingAnnotationIndex = index;
                resetComboBuffer();
                jumpToTime(annotation.timestamp);
                
                // Show visual feedback that we're in edit mode
                setComboDisplay('EDIT MODE - Type abbreviation to change label', 'status-pending');
                showToast({ name: 'Edit Mode' }, false);
                
                updateTaggedTechnicalLabels();
            }
        }

        // Delete technical annotation
        function deleteTechnicalAnnotation(index) {
            const annotation = annotations[index];
            if (!annotation || !annotation.is_technical) return;

            const deletedTimestamp = annotation.timestamp;

            if (editingAnnotationIndex === index) {
                editingAnnotationIndex = null;
            } else if (editingAnnotationIndex !== null && editingAnnotationIndex > index) {
                editingAnnotationIndex -= 1;
            }

            annotations.splice(index, 1);
            saveAnnotations();
            updateTaggedTechnicalLabels();

            // Keep video at deleted frame
            if (video && video.readyState >= 2) {
                video.currentTime = deletedTimestamp;
                video.pause();
                updateFrameInfo();
            }
        }

        // Toggle tagged technical labels section
        function toggleTaggedTechnical() {
            const list = document.getElementById('taggedTechnicalList');
            const header = document.querySelector('.tagged-technical-header');
            if (!list || !header) return;

            const isVisible = list.style.display !== 'none';
            list.style.display = isVisible ? 'none' : 'block';
            header.classList.toggle('collapsed', isVisible);
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', init);

        // ========== COURT POSITION MODE ==========
        
        // Court Mode State
        let currentMode = 'match'; // 'match', 'technical', 'court'
        let courtInputMode = 'canvas'; // 'zone' or 'canvas'
        let courtAnnotations = [];
        let courtVideo = null;
        let courtFps = 30;
        let courtFrameRate = 1 / 30;
        
        // Match State
        let currentGame = 1;
        let currentRally = 1;
        let currentShotNum = 0;
        let p1Score = 0;
        let p2Score = 0;
        let currentServer = null; // 'P1' or 'P2'
        let currentHitter = null; // Who is currently hitting
        let rallyInProgress = false;
        let waitingForServer = false;
        let isServing = false; // True when first shot of rally (serve) is being annotated

        // Shot Selection State
        let selectedFromZone = null;
        let selectedToZone = null;
        let currentRallyShots = [];

        // Shot Override State (for manual shot type override via keyboard combos)
        let overriddenShotType = null;
        let courtComboBuffer = '';
        let courtComboTimeout = null;
        
        // Canvas Mode State
        let isCalibrated = false;
        let isCalibrating = false;
        let showDebugOverlay = false; // Show colored zone overlay for debugging calibration
        let calibrationPoints = []; // Array of {x, y} pixel coordinates (10 points)
        
        // 4 piecewise homography matrices
        let homographyP2Back = null;  // P2 baseline ‚Üí P2 service line
        let homographyP2Front = null; // P2 service line ‚Üí Net
        let homographyP1Front = null; // Net ‚Üí P1 service line
        let homographyP1Back = null;  // P1 service line ‚Üí P1 baseline
        
        // Y boundaries in video pixels for selecting correct homography
        let p2ServiceYInVideo = 0;
        let netYInVideo = 0;
        let p1ServiceYInVideo = 0;
        
        let calibrationCanvasWidth = 0; // Canvas width at calibration time
        let calibrationCanvasHeight = 0; // Canvas height at calibration time
        
        // Trajectory State
        let currentTrajectory = 0; // -1 (down), 0 (flat), 1 (up)
        let defaultTrajectory = 0; // Default trajectory for current shot type
        let trajectoryOverridden = false;
        
        // Coordinates for clicked positions
        let fromCoords = null; // {x, y} in meters
        let toCoords = null; // {x, y} in meters
        
        // Click markers
        let fromMarker = null;
        let toMarker = null;
        
        // Court dimensions (singles)
        const COURT_WIDTH = 5.18; // meters
        const COURT_LENGTH = 13.4; // meters
        const NET_Y = 6.7; // meters from P2's baseline
        const SERVICE_LINE_DIST = 1.98; // meters from net
        
        // Calculated Y positions for service lines
        const P2_SERVICE_Y = NET_Y - SERVICE_LINE_DIST; // 4.72m
        const P1_SERVICE_Y = NET_Y + SERVICE_LINE_DIST; // 8.68m
        
        // Calibration point definitions (10 points for improved accuracy)
        const CALIB_POINTS = [
            { name: "P2 Baseline Left", x: 0, y: 0 },
            { name: "P2 Baseline Right", x: COURT_WIDTH, y: 0 },
            { name: "P2 Service Line Left", x: 0, y: P2_SERVICE_Y },
            { name: "P2 Service Line Right", x: COURT_WIDTH, y: P2_SERVICE_Y },
            { name: "Net Left", x: 0, y: NET_Y },
            { name: "Net Right", x: COURT_WIDTH, y: NET_Y },
            { name: "P1 Service Line Left", x: 0, y: P1_SERVICE_Y },
            { name: "P1 Service Line Right", x: COURT_WIDTH, y: P1_SERVICE_Y },
            { name: "P1 Baseline Left", x: 0, y: COURT_LENGTH },
            { name: "P1 Baseline Right", x: COURT_WIDTH, y: COURT_LENGTH }
        ];
        
        // Default trajectory mapping based on from/to zones
        const defaultTrajectoryMap = {
            // From Back -> To
            'back->front': -1,  // drop/pulldrop
            'back->mid': -1,    // smash
            'back->back': 1,    // clear
            // From Mid -> To
            'mid->front': 0,    // defense block
            'mid->mid': 0,      // drive
            'mid->back': 1,     // lift
            // From Front -> To
            'front->front': -1, // net tap/dribble
            'front->mid': 0,    // push
            'front->back': 1    // lift
        };
        
        // Player Setup
        let p1Name = 'P1';
        let p2Name = 'P2';
        let p1Hand = 'right';
        let p2Hand = 'right';

        // Shot Modifier States
        let zone6Mode = 'overhead';  // 'overhead' (default) or 'backhand' - for Zone 6 (Back BH) shots
        let dribbleMode = false;     // When true, straight net shots (1‚Üí1, 2‚Üí2) become dribble instead of netkeep

        // Shot Mapping for Court Position Mode
        // New 6-zone system: 1=Front FH, 2=Front BH, 3=Mid FH, 4=Mid BH, 5=Back FH, 6=Back BH
        // Shot inference is now dynamic based on: FROM zone, TO zone, trajectory, zone6Mode, dribbleMode
        // Cross-court suffix: added when shot travels from FH side (odd zones) to BH side (even zones) or vice versa
        // See inferShotTypeWithTrajectory() for complete mapping logic
        
        // ========== CANVAS MODE FUNCTIONS ==========
        
        // Switch between zone click and canvas click modes
        function setCourtInputMode(mode) {
            courtInputMode = mode;
            
            // Update button states
            document.getElementById('zoneModeBtn').classList.toggle('active', mode === 'zone');
            document.getElementById('canvasModeBtn').classList.toggle('active', mode === 'canvas');
            
            // Show/hide zone-based court map vs canvas overlay
            const courtMap = document.getElementById('courtMap');
            const overlayCanvas = document.getElementById('courtOverlayCanvas');
            
            if (mode === 'zone') {
                if (courtMap) courtMap.style.display = 'flex';
                if (overlayCanvas) overlayCanvas.classList.remove('interactive');
                document.getElementById('coordDisplay').style.display = 'none';
            } else {
                if (courtMap) courtMap.style.display = 'none';
                if (overlayCanvas && isCalibrated) {
                    overlayCanvas.classList.add('interactive');
                }
            }
            
            // Update trajectory selector visibility
            updateTrajectorySelector();
        }
        
        // Start calibration process
        function startCalibration() {
            const courtVideoEl = document.getElementById('courtVideoPlayer');
            if (!courtVideoEl || courtVideoEl.readyState < 2) {
                alert('Please load a video first!');
                return;
            }
            
            // Pause video
            courtVideoEl.pause();
            
            // Reset calibration state
            calibrationPoints = [];
            isCalibrating = true;
            
            // Show calibration panel (above video) and canvas
            const panel = document.getElementById('calibrationPanel');
            const canvas = document.getElementById('calibrationCanvas');
            const indicator = document.getElementById('calibrationCurrentIndicator');
            
            if (panel && canvas) {
                panel.classList.add('active');
                canvas.style.display = 'block';
                if (indicator) indicator.classList.add('active');
                
                // Size canvas to match video
                const videoRect = courtVideoEl.getBoundingClientRect();
                canvas.width = videoRect.width;
                canvas.height = videoRect.height;
                canvas.style.width = videoRect.width + 'px';
                canvas.style.height = videoRect.height + 'px';
                
                // Setup canvas click handler
                canvas.onclick = handleCalibrationClick;
                canvas.onmousemove = handleCalibrationMouseMove;
                
                // Update calibration points list
                updateCalibrationPointsList();
                updateCalibrationIndicator();
                
                // Draw initial state
                drawCalibrationCanvas();
            }
        }
        
        // Update the current point indicator text
        function updateCalibrationIndicator() {
            const indicator = document.getElementById('calibrationCurrentIndicator');
            if (!indicator) return;
            
            const pointNames = [
                'P2 Baseline Left (top-left)',
                'P2 Baseline Right (top-right)',
                'P2 Service Line Left',
                'P2 Service Line Right',
                'Net Left',
                'Net Right',
                'P1 Service Line Left',
                'P1 Service Line Right',
                'P1 Baseline Left (bottom-left)',
                'P1 Baseline Right (bottom-right)'
            ];
            
            if (calibrationPoints.length < 10) {
                const nextPoint = calibrationPoints.length + 1;
                indicator.textContent = `Click: Point ${nextPoint} ‚Äî ${pointNames[calibrationPoints.length]}`;
                indicator.classList.add('active');
            } else {
                indicator.textContent = 'All 10 points marked! Click "Confirm" to save.';
            }
        }
        
        // Handle click during calibration
        function handleCalibrationClick(e) {
            if (!isCalibrating) return;
            if (calibrationPoints.length >= 10) return;
            
            const canvas = document.getElementById('calibrationCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Add point
            calibrationPoints.push({ x, y });
            
            // Update UI
            updateCalibrationPointsList();
            updateCalibrationIndicator();
            drawCalibrationCanvas();
            
            // Enable/disable buttons
            document.getElementById('calibUndoBtn').disabled = calibrationPoints.length === 0;
            document.getElementById('calibConfirmBtn').disabled = calibrationPoints.length < 10;
        }
        
        // Handle mouse move during calibration (for crosshair)
        function handleCalibrationMouseMove(e) {
            if (!isCalibrating) return;
            
            const canvas = document.getElementById('calibrationCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            drawCalibrationCanvas(x, y);
        }
        
        // Draw calibration canvas
        function drawCalibrationCanvas(mouseX = null, mouseY = null) {
            const canvas = document.getElementById('calibrationCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw placed points (10 colors for 10 points)
            const colors = [
                '#e74c3c', '#e67e22',  // P2 Baseline (red, orange)
                '#f39c12', '#f1c40f',  // P2 Service Line (dark yellow, yellow)
                '#2ecc71', '#27ae60',  // Net (green, dark green)
                '#3498db', '#2980b9',  // P1 Service Line (blue, dark blue)
                '#9b59b6', '#8e44ad'   // P1 Baseline (purple, dark purple)
            ];
            
            calibrationPoints.forEach((point, idx) => {
                // Point circle (smaller for better edge precision)
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = colors[idx % colors.length];
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 8px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(idx + 1, point.x, point.y + 3);
            });
            
            // Draw horizontal lines connecting point pairs
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            // Horizontal lines: each pair of points (0-1, 2-3, 4-5, 6-7, 8-9)
            const horizontalPairs = [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]];
            for (const [a, b] of horizontalPairs) {
                if (calibrationPoints.length > b) {
                    ctx.beginPath();
                    ctx.moveTo(calibrationPoints[a].x, calibrationPoints[a].y);
                    ctx.lineTo(calibrationPoints[b].x, calibrationPoints[b].y);
                    ctx.stroke();
                }
            }
            
            // Net line thicker
            if (calibrationPoints.length >= 6) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(calibrationPoints[4].x, calibrationPoints[4].y);
                ctx.lineTo(calibrationPoints[5].x, calibrationPoints[5].y);
                ctx.stroke();
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            }
            
            // Left sideline (points 0-2-4-6-8)
            if (calibrationPoints.length >= 1) {
                ctx.beginPath();
                ctx.moveTo(calibrationPoints[0].x, calibrationPoints[0].y);
                for (let i = 2; i <= 8 && i < calibrationPoints.length; i += 2) {
                    ctx.lineTo(calibrationPoints[i].x, calibrationPoints[i].y);
                }
                ctx.stroke();
            }
            
            // Right sideline (points 1-3-5-7-9)
            if (calibrationPoints.length >= 2) {
                ctx.beginPath();
                ctx.moveTo(calibrationPoints[1].x, calibrationPoints[1].y);
                for (let i = 3; i <= 9 && i < calibrationPoints.length; i += 2) {
                    ctx.lineTo(calibrationPoints[i].x, calibrationPoints[i].y);
                }
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            
            // Draw crosshair at mouse position
            if (mouseX !== null && mouseY !== null && calibrationPoints.length < 10) {
                ctx.strokeStyle = 'rgba(241, 196, 15, 0.8)';
                ctx.lineWidth = 1;
                
                // Horizontal line
                ctx.beginPath();
                ctx.moveTo(0, mouseY);
                ctx.lineTo(canvas.width, mouseY);
                ctx.stroke();
                
                // Vertical line
                ctx.beginPath();
                ctx.moveTo(mouseX, 0);
                ctx.lineTo(mouseX, canvas.height);
                ctx.stroke();
                
                // Cursor circle (smaller for precision)
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 6, 0, Math.PI * 2);
                ctx.strokeStyle = colors[calibrationPoints.length % colors.length];
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }
        
        // Update calibration points list in UI
        function updateCalibrationPointsList() {
            const container = document.getElementById('calibrationPointsList');
            if (!container) return;
            
            const items = container.querySelectorAll('.calibration-point');
            items.forEach((item, idx) => {
                item.classList.remove('done', 'active');
                if (idx < calibrationPoints.length) {
                    item.classList.add('done');
                } else if (idx === calibrationPoints.length) {
                    item.classList.add('active');
                }
            });
        }
        
        // Undo last calibration point
        function undoCalibrationPoint() {
            if (calibrationPoints.length > 0) {
                calibrationPoints.pop();
                updateCalibrationPointsList();
                updateCalibrationIndicator();
                drawCalibrationCanvas();
                
                document.getElementById('calibUndoBtn').disabled = calibrationPoints.length === 0;
                document.getElementById('calibConfirmBtn').disabled = calibrationPoints.length < 10;
            }
        }
        
        // Reset calibration
        function resetCalibration() {
            calibrationPoints = [];
            updateCalibrationPointsList();
            updateCalibrationIndicator();
            drawCalibrationCanvas();
            
            document.getElementById('calibUndoBtn').disabled = true;
            document.getElementById('calibConfirmBtn').disabled = true;
        }
        
        // Cancel calibration and hide UI
        function cancelCalibration() {
            isCalibrating = false;
            calibrationPoints = [];
            
            // Hide calibration UI
            const panel = document.getElementById('calibrationPanel');
            const canvas = document.getElementById('calibrationCanvas');
            const indicator = document.getElementById('calibrationCurrentIndicator');
            
            if (panel) panel.classList.remove('active');
            if (canvas) canvas.style.display = 'none';
            if (indicator) indicator.classList.remove('active');
        }
        
        // Confirm calibration and compute homographies
        function confirmCalibration() {
            if (calibrationPoints.length < 10) {
                alert('Please place all 10 calibration points.');
                return;
            }
            
            // Compute 4 piecewise homographies for improved accuracy
            try {
                // P2 Back: points 0,1,2,3 -> baseline to service line
                homographyP2Back = computeHomography(
                    [calibrationPoints[0], calibrationPoints[1], calibrationPoints[2], calibrationPoints[3]],
                    [
                        { x: 0, y: 0 },
                        { x: COURT_WIDTH, y: 0 },
                        { x: 0, y: P2_SERVICE_Y },
                        { x: COURT_WIDTH, y: P2_SERVICE_Y }
                    ]
                );
                
                // P2 Front: points 2,3,4,5 -> service line to net
                homographyP2Front = computeHomography(
                    [calibrationPoints[2], calibrationPoints[3], calibrationPoints[4], calibrationPoints[5]],
                    [
                        { x: 0, y: P2_SERVICE_Y },
                        { x: COURT_WIDTH, y: P2_SERVICE_Y },
                        { x: 0, y: NET_Y },
                        { x: COURT_WIDTH, y: NET_Y }
                    ]
                );
                
                // P1 Front: points 4,5,6,7 -> net to service line
                homographyP1Front = computeHomography(
                    [calibrationPoints[4], calibrationPoints[5], calibrationPoints[6], calibrationPoints[7]],
                    [
                        { x: 0, y: NET_Y },
                        { x: COURT_WIDTH, y: NET_Y },
                        { x: 0, y: P1_SERVICE_Y },
                        { x: COURT_WIDTH, y: P1_SERVICE_Y }
                    ]
                );
                
                // P1 Back: points 6,7,8,9 -> service line to baseline
                homographyP1Back = computeHomography(
                    [calibrationPoints[6], calibrationPoints[7], calibrationPoints[8], calibrationPoints[9]],
                    [
                        { x: 0, y: P1_SERVICE_Y },
                        { x: COURT_WIDTH, y: P1_SERVICE_Y },
                        { x: 0, y: COURT_LENGTH },
                        { x: COURT_WIDTH, y: COURT_LENGTH }
                    ]
                );
                
                // Store Y boundaries in video pixels
                p2ServiceYInVideo = (calibrationPoints[2].y + calibrationPoints[3].y) / 2;
                netYInVideo = (calibrationPoints[4].y + calibrationPoints[5].y) / 2;
                p1ServiceYInVideo = (calibrationPoints[6].y + calibrationPoints[7].y) / 2;
                
                // Store calibration canvas dimensions
                const calibCanvasEl = document.getElementById('calibrationCanvas');
                if (calibCanvasEl) {
                    calibrationCanvasWidth = calibCanvasEl.width;
                    calibrationCanvasHeight = calibCanvasEl.height;
                }

                isCalibrated = true;
                isCalibrating = false;
                
                // Save calibration
                saveCalibration();
                
                // Update UI
                updateCalibrationStatus();
                
                // Hide calibration panel and canvas
                const panel = document.getElementById('calibrationPanel');
                const indicator = document.getElementById('calibrationCurrentIndicator');
                
                if (panel) panel.classList.remove('active');
                if (calibCanvasEl) calibCanvasEl.style.display = 'none';
                if (indicator) indicator.classList.remove('active');

                // Wait for layout to stabilize after hiding calibration panel
                // Use requestAnimationFrame + setTimeout to ensure DOM has repainted
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        // Draw court overlay after layout is stable
                        drawCourtOverlay();

                        // Enable canvas interaction
                        const overlayCanvas = document.getElementById('courtOverlayCanvas');
                        if (overlayCanvas && courtInputMode === 'canvas') {
                            overlayCanvas.classList.add('interactive');
                        }
                    }, 50);
                });
                
                showToast({ name: 'Calibration Complete' }, false);

                // Log feedback for algorithm improvement (if auto-detection was used)
                if (typeof CourtCalibration !== 'undefined' && CourtCalibration.logFeedback) {
                    const courtVideoEl = document.getElementById('courtVideoPlayer');
                    if (courtVideoEl) {
                        const frameNumber = Math.floor(courtVideoEl.currentTime * courtFps);
                        CourtCalibration.logFeedback(
                            videoFileName || 'unknown',
                            frameNumber,
                            courtVideoEl.videoWidth,
                            courtVideoEl.videoHeight,
                            courtFps
                        );
                    }
                }

            } catch (error) {
                console.error('Calibration error:', error);
                console.error('Calibration points at failure:', JSON.stringify(calibrationPoints));
                console.error('calibrationCanvasWidth:', calibrationCanvasWidth, 'calibrationCanvasHeight:', calibrationCanvasHeight);
                alert('Calibration failed: ' + error.message + '\n\nPlease check the browser console for details.');
            }
        }
        
        // Compute 3x3 homography matrix using Direct Linear Transform (DLT)
        // Maps srcPoints (pixels) to dstPoints (court coordinates)
        function computeHomography(srcPoints, dstPoints) {
            // Validate input points
            if (!srcPoints || srcPoints.length !== 4) {
                throw new Error('computeHomography requires exactly 4 source points');
            }
            if (!dstPoints || dstPoints.length !== 4) {
                throw new Error('computeHomography requires exactly 4 destination points');
            }

            // Check for undefined/null/NaN coordinates
            for (let i = 0; i < 4; i++) {
                if (!srcPoints[i] || typeof srcPoints[i].x !== 'number' || typeof srcPoints[i].y !== 'number' ||
                    isNaN(srcPoints[i].x) || isNaN(srcPoints[i].y)) {
                    throw new Error(`Invalid source point at index ${i}: ${JSON.stringify(srcPoints[i])}`);
                }
                if (!dstPoints[i] || typeof dstPoints[i].x !== 'number' || typeof dstPoints[i].y !== 'number' ||
                    isNaN(dstPoints[i].x) || isNaN(dstPoints[i].y)) {
                    throw new Error(`Invalid destination point at index ${i}: ${JSON.stringify(dstPoints[i])}`);
                }
            }

            // For 4 points, we can solve directly
            // Using the standard DLT with proper SVD approximation via inverse iteration

            // First, normalize points for numerical stability
            function normalizePoints(points) {
                let cx = 0, cy = 0;
                for (const p of points) { cx += p.x; cy += p.y; }
                cx /= points.length;
                cy /= points.length;

                let scale = 0;
                for (const p of points) {
                    scale += Math.sqrt((p.x - cx) ** 2 + (p.y - cy) ** 2);
                }

                // Check for degenerate case (all points at same location)
                if (scale < 1e-10) {
                    throw new Error('Points are degenerate (all at same location or too close together)');
                }

                scale = (Math.sqrt(2) * points.length) / scale;
                
                const normalized = points.map(p => ({
                    x: scale * (p.x - cx),
                    y: scale * (p.y - cy)
                }));
                
                // Transformation matrix T such that normalized = T * original
                const T = [
                    [scale, 0, -scale * cx],
                    [0, scale, -scale * cy],
                    [0, 0, 1]
                ];
                
                return { points: normalized, T, cx, cy, scale };
            }
            
            const srcNorm = normalizePoints(srcPoints);
            const dstNorm = normalizePoints(dstPoints);
            
            // Build DLT matrix A (8x9)
            const A = [];
            for (let i = 0; i < 4; i++) {
                const sx = srcNorm.points[i].x;
                const sy = srcNorm.points[i].y;
                const dx = dstNorm.points[i].x;
                const dy = dstNorm.points[i].y;
                
                A.push([-sx, -sy, -1, 0, 0, 0, dx * sx, dx * sy, dx]);
                A.push([0, 0, 0, -sx, -sy, -1, dy * sx, dy * sy, dy]);
            }
            
            // Solve Ah = 0 using SVD (find smallest singular value's vector)
            // We use inverse iteration to find the null space
            const h = solveNullSpace(A);
            
            // Construct normalized homography
            const Hnorm = [
                [h[0], h[1], h[2]],
                [h[3], h[4], h[5]],
                [h[6], h[7], h[8]]
            ];
            
            // Denormalize: H = inv(Tdst) * Hnorm * Tsrc
            const TsrcInv = [
                [1/srcNorm.scale, 0, srcNorm.cx],
                [0, 1/srcNorm.scale, srcNorm.cy],
                [0, 0, 1]
            ];
            const Tdst = dstNorm.T;
            
            // H = Tdst^(-1) * Hnorm * Tsrc
            // First: temp = Hnorm * Tsrc (but we want Hnorm * Tsrc^(-1), so use TsrcInv)
            // Actually: H = Tdst^(-1) * Hnorm * Tsrc
            // Tsrc transforms original src to normalized src
            // So Tsrc^(-1) transforms normalized to original
            // We want: original_dst = H * original_src
            // normalized_dst = Hnorm * normalized_src
            // Tdst * original_dst = Hnorm * Tsrc * original_src
            // original_dst = Tdst^(-1) * Hnorm * Tsrc * original_src
            
            const TdstInv = [
                [1/dstNorm.scale, 0, dstNorm.cx],
                [0, 1/dstNorm.scale, dstNorm.cy],
                [0, 0, 1]
            ];
            
            // Multiply: TdstInv * Hnorm
            const temp = multiplyMatrix3x3(TdstInv, Hnorm);
            // Then: temp * Tsrc
            const H = multiplyMatrix3x3(temp, srcNorm.T);
            
            // Normalize so H[2][2] = 1
            const scale = H[2][2];
            if (Math.abs(scale) < 1e-10) {
                throw new Error('Homography matrix is degenerate (H[2][2] ‚âà 0). Points may be collinear or invalid.');
            }
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    H[i][j] /= scale;
                }
            }

            // Validate result matrix doesn't contain NaN or Infinity
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (!isFinite(H[i][j])) {
                        throw new Error(`Homography computation resulted in invalid value at [${i}][${j}]: ${H[i][j]}`);
                    }
                }
            }

            return H;
        }
        
        // Multiply two 3x3 matrices
        function multiplyMatrix3x3(A, B) {
            const C = [[0,0,0], [0,0,0], [0,0,0]];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    for (let k = 0; k < 3; k++) {
                        C[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return C;
        }
        
        // Solve for null space of A using inverse iteration
        function solveNullSpace(A) {
            // Compute A^T * A (9x9 matrix)
            const ATA = [];
            for (let i = 0; i < 9; i++) {
                ATA[i] = [];
                for (let j = 0; j < 9; j++) {
                    let sum = 0;
                    for (let k = 0; k < A.length; k++) {
                        sum += A[k][i] * A[k][j];
                    }
                    ATA[i][j] = sum;
                }
            }
            
            // Add small regularization for numerical stability
            for (let i = 0; i < 9; i++) {
                ATA[i][i] += 1e-10;
            }
            
            // Inverse iteration: solve (A^T*A) * x = b repeatedly
            // Starting vector
            let h = [1, 1, 1, 1, 1, 1, 1, 1, 1];
            
            for (let iter = 0; iter < 50; iter++) {
                // Solve ATA * h_new = h using Gaussian elimination
                const h_new = solveLinearSystem(ATA, h);
                
                // Normalize
                let norm = 0;
                for (let i = 0; i < 9; i++) norm += h_new[i] * h_new[i];
                norm = Math.sqrt(norm);
                
                for (let i = 0; i < 9; i++) h[i] = h_new[i] / norm;
            }
            
            return h;
        }
        
        // Solve linear system Ax = b using Gaussian elimination with partial pivoting
        function solveLinearSystem(A, b) {
            const n = 9;
            // Create augmented matrix
            const M = [];
            for (let i = 0; i < n; i++) {
                M[i] = [...A[i], b[i]];
            }
            
            // Forward elimination with partial pivoting
            for (let col = 0; col < n; col++) {
                // Find pivot
                let maxRow = col;
                let maxVal = Math.abs(M[col][col]);
                for (let row = col + 1; row < n; row++) {
                    if (Math.abs(M[row][col]) > maxVal) {
                        maxVal = Math.abs(M[row][col]);
                        maxRow = row;
                    }
                }
                
                // Swap rows
                [M[col], M[maxRow]] = [M[maxRow], M[col]];
                
                // Eliminate
                for (let row = col + 1; row < n; row++) {
                    const factor = M[row][col] / M[col][col];
                    for (let j = col; j <= n; j++) {
                        M[row][j] -= factor * M[col][j];
                    }
                }
            }
            
            // Back substitution
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = M[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= M[i][j] * x[j];
                }
                x[i] /= M[i][i];
            }
            
            return x;
        }
        
        // Apply homography to transform point
        function applyHomography(H, x, y) {
            const w = H[2][0] * x + H[2][1] * y + H[2][2];
            const px = (H[0][0] * x + H[0][1] * y + H[0][2]) / w;
            const py = (H[1][0] * x + H[1][1] * y + H[1][2]) / w;
            return { x: px, y: py };
        }
        
        // Invert homography matrix
        function invertHomography(H) {
            const a = H[0][0], b = H[0][1], c = H[0][2];
            const d = H[1][0], e = H[1][1], f = H[1][2];
            const g = H[2][0], h = H[2][1], i = H[2][2];
            
            const det = a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
            
            if (Math.abs(det) < 1e-10) {
                throw new Error('Matrix is singular');
            }
            
            const invDet = 1 / det;
            
            return [
                [(e*i - f*h) * invDet, (c*h - b*i) * invDet, (b*f - c*e) * invDet],
                [(f*g - d*i) * invDet, (a*i - c*g) * invDet, (c*d - a*f) * invDet],
                [(d*h - e*g) * invDet, (b*g - a*h) * invDet, (a*e - b*d) * invDet]
            ];
        }
        
        // Convert video pixel coordinates to court coordinates
        function videoToCourtCoords(pixelX, pixelY) {
            if (!isCalibrated) return null;
            
            try {
                // Select correct homography based on pixel Y position (4 zones)
                if (pixelY < p2ServiceYInVideo) {
                    // P2 Back court: baseline to service line
                    return applyHomography(homographyP2Back, pixelX, pixelY);
                } else if (pixelY < netYInVideo) {
                    // P2 Front court: service line to net
                    return applyHomography(homographyP2Front, pixelX, pixelY);
                } else if (pixelY < p1ServiceYInVideo) {
                    // P1 Front court: net to service line
                    return applyHomography(homographyP1Front, pixelX, pixelY);
                } else {
                    // P1 Back court: service line to baseline
                    return applyHomography(homographyP1Back, pixelX, pixelY);
                }
            } catch (e) {
                console.error('Error in videoToCourtCoords:', e);
                return null;
            }
        }
        
        // Convert court coordinates to video pixel coordinates
        function courtToVideoCoords(courtX, courtY) {
            if (!isCalibrated) return null;
            
            try {
                // Select correct homography based on court Y position (4 zones)
                let H;
                if (courtY < P2_SERVICE_Y) {
                    // P2 Back court: baseline to service line
                    H = homographyP2Back;
                } else if (courtY < NET_Y) {
                    // P2 Front court: service line to net
                    H = homographyP2Front;
                } else if (courtY < P1_SERVICE_Y) {
                    // P1 Front court: net to service line
                    H = homographyP1Front;
                } else {
                    // P1 Back court: service line to baseline
                    H = homographyP1Back;
                }
                
                // Invert homography (it maps pixels‚Üícourt, we need court‚Üípixels)
                const invH = invertHomography(H);
                return applyHomography(invH, courtX, courtY);
            } catch (e) {
                console.error('Error converting court to video coords:', e);
                return null;
            }
        }
        
        // Round to 10cm precision
        function roundTo10cm(value) {
            return Math.round(value * 10) / 10;
        }
        
        // Get zone from court coordinates
        // Simplified 3-area system: Front, Mid, Back with FH/BH
        function getZoneFromCoords(x, y) {
            // Determine which player's side
            const isP2Side = y < NET_Y;
            const suffix = isP2Side ? 'b' : 'a';

            // Normalize Y to distance from net (0 = at net, increasing toward baseline)
            const distFromNet = isP2Side ? (NET_Y - y) : (y - NET_Y);

            const isRightSide = x > COURT_WIDTH / 2;

            // Flip FH/BH for P2 (they face opposite direction)
            const isFH = isP2Side ? !isRightSide : isRightSide;

            // Zone boundaries (distance from net):
            // Front: 0 - 2.5m from net
            // Mid: 2.5 - 4.5m from net
            // Back: 4.5m+ to baseline (6.7m from net)

            if (distFromNet < 2.5) {
                // Front court (near net)
                return isFH ? ('1' + suffix) : ('2' + suffix);
            } else if (distFromNet < 4.5) {
                // Mid court
                return isFH ? ('3' + suffix) : ('4' + suffix);
            } else {
                // Back court (near baseline)
                return isFH ? ('5' + suffix) : ('6' + suffix);
            }
        }
        
        // Toggle debug overlay
        function toggleDebugOverlay() {
            showDebugOverlay = !showDebugOverlay;
            const btn = document.getElementById('debugOverlayBtn');
            if (btn) {
                btn.classList.toggle('active', showDebugOverlay);
                btn.textContent = showDebugOverlay ? 'üé® Debug ON' : 'üé® Debug';
            }
            drawCourtOverlay();
        }
        
        // Draw colored debug zones on the court overlay
        // Simplified 3-area system: Front, Mid, Back with FH/BH
        function drawDebugZones(ctx, scaleX = 1, scaleY = 1) {
            // Zone colors with transparency
            const zoneColors = {
                // Front (near net) - warm colors
                '1a': 'rgba(231, 76, 60, 0.4)',   // Front FH - Red
                '2a': 'rgba(230, 126, 34, 0.4)',  // Front BH - Orange
                '1b': 'rgba(231, 76, 60, 0.4)',   // Front FH - Red
                '2b': 'rgba(230, 126, 34, 0.4)',  // Front BH - Orange
                // Mid - neutral colors
                '3a': 'rgba(241, 196, 15, 0.4)',  // Mid FH - Yellow
                '4a': 'rgba(46, 204, 113, 0.4)',  // Mid BH - Green
                '3b': 'rgba(241, 196, 15, 0.4)',  // Mid FH - Yellow
                '4b': 'rgba(46, 204, 113, 0.4)',  // Mid BH - Green
                // Back (near baseline) - cool colors
                '5a': 'rgba(52, 152, 219, 0.4)',  // Back FH - Blue
                '6a': 'rgba(155, 89, 182, 0.4)',  // Back BH - Purple
                '5b': 'rgba(52, 152, 219, 0.4)',  // Back FH - Blue
                '6b': 'rgba(155, 89, 182, 0.4)',  // Back BH - Purple
            };

            // Zone boundaries (court coordinates)
            // Distance from net: Front 0-2.5m, Mid 2.5-4.5m, Back 4.5-6.7m
            const halfWidth = COURT_WIDTH / 2;

            // P2's side zones (y: 0 to NET_Y, where y=0 is P2 baseline)
            // P2 faces DOWN toward net. Their RIGHT is x<2.59, their LEFT is x>2.59
            // For right-handed P2: FH = their right (x<2.59), BH = their left (x>2.59)
            const p2Zones = [
                // Back court (y: 0 to 2.2)
                { zone: '5b', x1: 0, y1: 0, x2: halfWidth, y2: 2.2 },              // Back FH (P2's right)
                { zone: '6b', x1: halfWidth, y1: 0, x2: COURT_WIDTH, y2: 2.2 },    // Back BH (P2's left)
                // Mid court (y: 2.2 to 4.2)
                { zone: '3b', x1: 0, y1: 2.2, x2: halfWidth, y2: 4.2 },            // Mid FH
                { zone: '4b', x1: halfWidth, y1: 2.2, x2: COURT_WIDTH, y2: 4.2 },  // Mid BH
                // Front court (y: 4.2 to NET_Y)
                { zone: '1b', x1: 0, y1: 4.2, x2: halfWidth, y2: NET_Y },          // Front FH
                { zone: '2b', x1: halfWidth, y1: 4.2, x2: COURT_WIDTH, y2: NET_Y }, // Front BH
            ];

            // P1's side zones (y: NET_Y to COURT_LENGTH, where y=13.4 is P1 baseline)
            // P1 faces UP toward net. Their LEFT is x<2.59, their RIGHT is x>2.59
            // For right-handed P1: FH = their right (x>2.59), BH = their left (x<2.59)
            const p1Zones = [
                // Front court (y: NET_Y to 9.2)
                { zone: '1a', x1: halfWidth, y1: NET_Y, x2: COURT_WIDTH, y2: 9.2 }, // Front FH (P1's right)
                { zone: '2a', x1: 0, y1: NET_Y, x2: halfWidth, y2: 9.2 },           // Front BH (P1's left)
                // Mid court (y: 9.2 to 11.2)
                { zone: '3a', x1: halfWidth, y1: 9.2, x2: COURT_WIDTH, y2: 11.2 },  // Mid FH
                { zone: '4a', x1: 0, y1: 9.2, x2: halfWidth, y2: 11.2 },            // Mid BH
                // Back court (y: 11.2 to COURT_LENGTH)
                { zone: '5a', x1: halfWidth, y1: 11.2, x2: COURT_WIDTH, y2: COURT_LENGTH }, // Back FH
                { zone: '6a', x1: 0, y1: 11.2, x2: halfWidth, y2: COURT_LENGTH },           // Back BH
            ];
            
            // Draw all zones
            const allZones = [...p2Zones, ...p1Zones];
            
            for (const z of allZones) {
                const corners = [
                    courtToVideoCoords(z.x1, z.y1),
                    courtToVideoCoords(z.x2, z.y1),
                    courtToVideoCoords(z.x2, z.y2),
                    courtToVideoCoords(z.x1, z.y2)
                ];
                
                if (corners.every(c => c !== null)) {
                    ctx.beginPath();
                    ctx.moveTo(corners[0].x * scaleX, corners[0].y * scaleY);
                    ctx.lineTo(corners[1].x * scaleX, corners[1].y * scaleY);
                    ctx.lineTo(corners[2].x * scaleX, corners[2].y * scaleY);
                    ctx.lineTo(corners[3].x * scaleX, corners[3].y * scaleY);
                    ctx.closePath();
                    ctx.fillStyle = zoneColors[z.zone];
                    ctx.fill();

                    // Draw zone label
                    const centerX = (corners[0].x + corners[1].x + corners[2].x + corners[3].x) / 4 * scaleX;
                    const centerY = (corners[0].y + corners[1].y + corners[2].y + corners[3].y) / 4 * scaleY;
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.strokeStyle = 'rgba(0,0,0,0.7)';
                    ctx.lineWidth = 3;
                    ctx.strokeText(z.zone, centerX, centerY);
                    ctx.fillText(z.zone, centerX, centerY);
                }
            }
        }

        // Draw court overlay on video
        function drawCourtOverlay() {
            const canvas = document.getElementById('courtOverlayCanvas');
            const video = document.getElementById('courtVideoPlayer');

            if (!canvas || !video || !isCalibrated) return;

            // Size canvas to match video display
            const videoRect = video.getBoundingClientRect();
            canvas.width = videoRect.width;
            canvas.height = videoRect.height;
            // IMPORTANT: Also set CSS dimensions to match internal resolution
            canvas.style.width = videoRect.width + 'px';
            canvas.style.height = videoRect.height + 'px';

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Scale from calibration canvas size to current display size
            // Homography returns coordinates in calibrationCanvas space
            const scaleX = calibrationCanvasWidth > 0 ? canvas.width / calibrationCanvasWidth : 1;
            const scaleY = calibrationCanvasHeight > 0 ? canvas.height / calibrationCanvasHeight : 1;

            // Draw debug zones first (behind lines)
            if (showDebugOverlay) {
                drawDebugZones(ctx, scaleX, scaleY);
            }

            // Draw court lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 2;

            // Helper to draw line between court coordinates
            function drawCourtLine(x1, y1, x2, y2) {
                const p1 = courtToVideoCoords(x1, y1);
                const p2 = courtToVideoCoords(x2, y2);
                if (p1 && p2) {
                    ctx.beginPath();
                    // Scale from calibration canvas to current display
                    ctx.moveTo(p1.x * scaleX, p1.y * scaleY);
                    ctx.lineTo(p2.x * scaleX, p2.y * scaleY);
                    ctx.stroke();
                }
            }
            
            // Baselines
            drawCourtLine(0, 0, COURT_WIDTH, 0);
            drawCourtLine(0, COURT_LENGTH, COURT_WIDTH, COURT_LENGTH);
            
            // Sidelines
            drawCourtLine(0, 0, 0, COURT_LENGTH);
            drawCourtLine(COURT_WIDTH, 0, COURT_WIDTH, COURT_LENGTH);
            
            // Net
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 3;
            drawCourtLine(0, NET_Y, COURT_WIDTH, NET_Y);
            
            // Service lines (now calibration points - make more visible)
            ctx.strokeStyle = 'rgba(241, 196, 15, 0.7)';  // Yellow to match calibration color
            ctx.lineWidth = 2;
            drawCourtLine(0, P2_SERVICE_Y, COURT_WIDTH, P2_SERVICE_Y);
            drawCourtLine(0, P1_SERVICE_Y, COURT_WIDTH, P1_SERVICE_Y);
            
            // Center line (in service boxes)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            drawCourtLine(COURT_WIDTH / 2, P2_SERVICE_Y, COURT_WIDTH / 2, P1_SERVICE_Y);
            
            // Draw zone boundary lines in debug mode
            if (showDebugOverlay) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                
                // Mid-court split lines (y=4.0 for P2, y=9.4 for P1)
                drawCourtLine(0, 4.0, COURT_WIDTH, 4.0);
                drawCourtLine(0, 9.4, COURT_WIDTH, 9.4);
                
                // Net/Dribble split (y=5.7 for P2, y=7.7 for P1)
                drawCourtLine(0, 5.7, COURT_WIDTH, 5.7);
                drawCourtLine(0, 7.7, COURT_WIDTH, 7.7);
                
                // Dribble boundary (y=6.2 for P2, y=7.2 for P1)
                drawCourtLine(0, 6.2, COURT_WIDTH, 6.2);
                drawCourtLine(0, 7.2, COURT_WIDTH, 7.2);
                
                // Defense side boundaries
                drawCourtLine(1.7, 4.0, 1.7, 5.7);  // P2 left defense
                drawCourtLine(COURT_WIDTH - 1.7, 4.0, COURT_WIDTH - 1.7, 5.7);  // P2 right defense
                drawCourtLine(1.7, 7.7, 1.7, 9.4);  // P1 left defense
                drawCourtLine(COURT_WIDTH - 1.7, 7.7, COURT_WIDTH - 1.7, 9.4);  // P1 right defense
                
                ctx.setLineDash([]);
            }
            
            // Draw from/to markers if set (scale from calibration to display)
            if (fromMarker) {
                drawMarker(ctx, fromMarker.x * scaleX, fromMarker.y * scaleY, '#3498db', 'FROM');
            }
            if (toMarker) {
                drawMarker(ctx, toMarker.x * scaleX, toMarker.y * scaleY, '#9b59b6', 'TO');
            }
        }

        // Draw a marker at display coordinates
        function drawMarker(ctx, x, y, color, label) {
            // Circle
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Label
            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(label, x, y + 25);
        }
        
        // Save calibration to localStorage
        function saveCalibration() {
            const data = {
                points: calibrationPoints,
                homographyP2Back,
                homographyP2Front,
                homographyP1Front,
                homographyP1Back,
                p2ServiceYInVideo,
                netYInVideo,
                p1ServiceYInVideo,
                calibrationCanvasWidth,
                calibrationCanvasHeight
            };
            localStorage.setItem('courtCalibration', JSON.stringify(data));
        }
        
        // Load calibration from localStorage
        function loadCalibration() {
            const saved = localStorage.getItem('courtCalibration');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    calibrationPoints = data.points || [];
                    
                    // Support both old (2 homography) and new (4 homography) formats
                    if (data.homographyP2Back) {
                        // New 4-homography format
                        homographyP2Back = data.homographyP2Back;
                        homographyP2Front = data.homographyP2Front;
                        homographyP1Front = data.homographyP1Front;
                        homographyP1Back = data.homographyP1Back;
                        p2ServiceYInVideo = data.p2ServiceYInVideo || 0;
                        netYInVideo = data.netYInVideo || 0;
                        p1ServiceYInVideo = data.p1ServiceYInVideo || 0;
                    } else if (data.homographyP1 && data.homographyP2) {
                        // Old 2-homography format - need to recalibrate
                        console.log('Old calibration format detected. Please recalibrate with 10 points.');
                        return;
                    }
                    
                    calibrationCanvasWidth = data.calibrationCanvasWidth || 800;
                    calibrationCanvasHeight = data.calibrationCanvasHeight || 450;
                    
                    if (homographyP2Back && homographyP2Front && homographyP1Front && homographyP1Back) {
                        isCalibrated = true;
                        updateCalibrationStatus();
                        drawCourtOverlay();
                    }
                } catch (e) {
                    console.error('Error loading calibration:', e);
                }
            }
        }
        
        // Update calibration status display
        function updateCalibrationStatus() {
            const statusEl = document.getElementById('calibrationStatus');
            const textEl = document.getElementById('calibrationStatusText');
            const debugBtn = document.getElementById('debugOverlayBtn');
            
            if (statusEl && textEl) {
                if (isCalibrated) {
                    statusEl.classList.remove('not-calibrated');
                    statusEl.classList.add('calibrated');
                    statusEl.querySelector('.status-icon').textContent = '‚úì';
                    textEl.textContent = 'Calibrated - Court overlay active';
                    if (debugBtn) debugBtn.style.display = 'inline-block';
                } else {
                    statusEl.classList.remove('calibrated');
                    statusEl.classList.add('not-calibrated');
                    statusEl.querySelector('.status-icon').textContent = '‚ö†Ô∏è';
                    textEl.textContent = 'Not calibrated - Click "Calibrate" to set up court overlay';
                    if (debugBtn) debugBtn.style.display = 'none';
                }
            }
        }
        
        // Get default trajectory for a from->to zone transition
        function getDefaultTrajectory(fromZone, toZone) {
            // Determine zone categories (front/mid/back)
            function getCategory(zone) {
                const num = parseInt(zone.replace(/[ab]/g, ''));
                if (num <= 4) return 'front';
                if (num <= 7) return 'mid';
                return 'back';
            }
            
            const fromCat = getCategory(fromZone);
            const toCat = getCategory(toZone);
            const key = `${fromCat}->${toCat}`;
            
            return defaultTrajectoryMap[key] !== undefined ? defaultTrajectoryMap[key] : 0;
        }
        
        // Set trajectory (called from buttons or keyboard)
        function setTrajectory(traj) {
            currentTrajectory = traj;
            trajectoryOverridden = true;
            updateTrajectoryDisplay();
            updateCompactShotBar();

            // If we have a pending shot (from and to zones set), update the inferred shot type
            if (selectedFromZone && selectedToZone) {
                const shotType = inferShotTypeWithTrajectory(selectedFromZone, selectedToZone, currentTrajectory);
                document.getElementById('inferredShotType').textContent = formatShotName(shotType);
            }
        }
        
        // Update trajectory display
        function updateTrajectoryDisplay() {
            const buttons = document.querySelectorAll('.trajectory-btn');
            buttons.forEach(btn => {
                const traj = parseInt(btn.dataset.traj);
                btn.classList.toggle('active', traj === currentTrajectory);
                btn.classList.toggle('default-traj', traj === defaultTrajectory && !trajectoryOverridden);
            });
            
            const arrowEl = document.getElementById('trajArrowDisplay');
            const textEl = document.getElementById('trajTextDisplay');
            
            if (arrowEl && textEl) {
                const arrows = { '-1': '‚Üì', '0': '‚Üí', '1': '‚Üë' };
                const texts = { '-1': 'Downward', '0': 'Flat', '1': 'Upward' };
                
                arrowEl.textContent = arrows[currentTrajectory];
                textEl.textContent = texts[currentTrajectory] + (trajectoryOverridden ? '' : ' (default)');
            }
        }
        
        // Update trajectory selector visibility
        function updateTrajectorySelector() {
            const selector = document.getElementById('trajectorySelector');
            if (selector) {
                // Show trajectory selector when we're waiting for landing zone click
                const shouldShow = rallyInProgress && 
                                   courtInputMode === 'canvas' && 
                                   selectedFromZone && 
                                   !selectedToZone;
                selector.style.display = shouldShow ? 'flex' : 'none';
            }
        }
        
        // Infer shot type with trajectory consideration
        // Complete mapping logic with cross-court suffix, zone6Mode, and dribbleMode
        // Zone numbering: Odd (1,3,5) = FH side, Even (2,4,6) = BH side
        // Cross-court: when shot travels from FH side to BH side or vice versa
        // Trajectory: -1=Downward, 0=Flat, 1=Upward
        function inferShotTypeWithTrajectory(fromZone, toZone, trajectory) {
            // Extract zone numbers (remove player suffix 'a' or 'b')
            let fromNum = fromZone.replace(/[ab]/g, '');
            let toNum = toZone.replace(/[ab]/g, '');

            const fromN = parseInt(fromNum);
            const toN = parseInt(toNum);

            if (isNaN(fromN) || isNaN(toN)) return 'unknown';

            // Handle SERVE (first shot of rally)
            // FROM zones 1-4, TO zones 1-6
            // TO zones 1-4 (Front/Mid) ‚Üí serve_middle
            // TO zones 5-6 (Back) ‚Üí high_serve
            if (isServing) {
                if (toN >= 5) {
                    return 'high_serve';
                }
                return 'serve_middle';
            }

            // Determine if cross-court
            // Odd zones (1,3,5) = FH side, Even zones (2,4,6) = BH side
            // CROSS = SAME parity (odd‚Üíodd or even‚Üíeven) - shuttle crosses diagonally to same side type
            // STRAIGHT = different parity (odd‚Üíeven or even‚Üíodd) - shuttle goes straight across
            // Example: 6a‚Üí2b, 6a‚Üí4b, 6a‚Üí6b are all CROSS (even to even)
            const fromFH = (fromN % 2 === 1);
            const toFH = (toN % 2 === 1);
            const isCross = (fromFH === toFH);  // Cross when same parity (FH‚ÜíFH or BH‚ÜíBH)
            const crossSuffix = isCross ? '_cross' : '';

            // Get zone categories: 1-2 = Front, 3-4 = Mid, 5-6 = Back
            function getCategory(n) {
                if (n <= 2) return 'front';
                if (n <= 4) return 'mid';
                return 'back';
            }

            const fromCat = getCategory(fromN);
            const toCat = getCategory(toN);

            // FIRST: Determine base shot based on FROM zone, TO zone, and TRAJECTORY
            // Trajectory: -1 = Downward (‚Üì), 0 = Flat (‚Üí), 1 = Upward (‚Üë)
            let baseShot = 'unknown';

            // FROM FRONT (Zones 1, 2)
            if (fromCat === 'front') {
                if (toCat === 'front') {
                    // Front ‚Üí Front: netkeep (default), dribble with D key
                    if (!isCross && dribbleMode) {
                        baseShot = 'dribble';
                    } else {
                        baseShot = 'netkeep';
                    }
                } else if (toCat === 'mid') {
                    // Front ‚Üí Mid: ‚Üì nettap, ‚Üë lift, DEFAULT push
                    if (trajectory === -1) {
                        baseShot = 'nettap';
                    } else if (trajectory === 1) {
                        baseShot = 'lift';
                    } else {
                        baseShot = 'push';
                    }
                } else { // back
                    // Front ‚Üí Back: ‚Üì nettap, ‚Üë lift, DEFAULT lift
                    if (trajectory === -1) {
                        baseShot = 'nettap';
                    } else {
                        baseShot = 'lift';
                    }
                }
            }
            // FROM MID (Zones 3, 4)
            else if (fromCat === 'mid') {
                if (toCat === 'front') {
                    // Mid ‚Üí Front: ‚Üì block, ‚Üë defense, DEFAULT defense
                    if (trajectory === -1) {
                        baseShot = 'block';
                    } else {
                        baseShot = 'defense';
                    }
                } else if (toCat === 'mid') {
                    // Mid ‚Üí Mid: ‚Üì smash, ‚Üë clear, DEFAULT flatgame
                    if (trajectory === -1) {
                        baseShot = 'smash';
                    } else if (trajectory === 1) {
                        baseShot = 'clear';
                    } else {
                        baseShot = 'flatgame';
                    }
                } else { // back
                    // Mid ‚Üí Back: ‚Üì smash, ‚Üë clear, DEFAULT clear
                    if (trajectory === -1) {
                        baseShot = 'smash';
                    } else {
                        baseShot = 'clear';
                    }
                }
            }
            // FROM BACK (Zones 5, 6)
            else { // back
                if (toCat === 'front') {
                    // Back ‚Üí Front: ‚Üë pulldrop, DEFAULT drop
                    if (trajectory === 1) {
                        baseShot = 'pulldrop';
                    } else {
                        baseShot = 'drop';
                    }
                } else if (toCat === 'mid') {
                    // Back ‚Üí Mid: ‚Üì smash, ‚Üë clear, DEFAULT smash
                    if (trajectory === 1) {
                        baseShot = 'clear';
                    } else {
                        baseShot = 'smash';
                    }
                } else { // back
                    // Back ‚Üí Back: DEFAULT clear (all trajectories)
                    baseShot = 'clear';
                }
            }

            // SECOND: Determine stroke prefix based on FROM zone AND shot type
            // Prefix rules:
            // - Zone 1, 2 (Front): forehand_ / backhand_ based on FH/BH side
            // - Zone 3 (Mid FH): ALWAYS forehand_
            // - Zone 4 (Mid BH): overhead_ for smash/clear (default), backhand_ with B key; backhand_ for other shots
            // - Zone 5 (Back FH): ALWAYS forehand_
            // - Zone 6 (Back BH): overhead_ (default), backhand_ with B key
            let strokePrefix = '';
            const isSmashOrClear = (baseShot === 'smash' || baseShot === 'clear');

            if (fromN === 1 || fromN === 2) {
                // Front zones: forehand or backhand based on FH/BH side
                strokePrefix = fromFH ? 'forehand_' : 'backhand_';
            } else if (fromN === 3) {
                // Mid FH: ALWAYS forehand
                strokePrefix = 'forehand_';
            } else if (fromN === 4) {
                // Mid BH: overhead for smash/clear (default), backhand with B key; backhand for other shots
                if (isSmashOrClear) {
                    strokePrefix = (zone6Mode === 'backhand') ? 'backhand_' : 'overhead_';
                } else {
                    strokePrefix = 'backhand_';
                }
            } else if (fromN === 5) {
                // Back FH: ALWAYS forehand
                strokePrefix = 'forehand_';
            } else if (fromN === 6) {
                // Back BH: overhead (default), backhand with B key
                strokePrefix = (zone6Mode === 'backhand') ? 'backhand_' : 'overhead_';
            }

            return strokePrefix + baseShot + crossSuffix;
        }

        // Reset shot modifier states after each shot is recorded
        function resetShotModifiers() {
            zone6Mode = 'overhead';
            dribbleMode = false;
            isServing = false; // After first shot, no longer serving
            updateModeIndicators();
        }

        // Update UI to show current modifier states
        function updateModeIndicators() {
            const indicator = document.getElementById('shotModeIndicator');
            if (!indicator) return;

            const modes = [];
            if (zone6Mode === 'backhand') modes.push('BH Mode');
            if (dribbleMode) modes.push('Dribble');

            if (modes.length > 0) {
                indicator.textContent = modes.join(' | ');
                indicator.style.display = 'block';
            } else {
                indicator.style.display = 'none';
            }
        }
        
        // Mode switching
        function setMode(mode) {
            currentMode = mode;
            
            // Update button states
            document.getElementById('modeMatchBtn').classList.toggle('active', mode === 'match');
            document.getElementById('modeTechnicalBtn').classList.toggle('active', mode === 'technical');
            document.getElementById('modeCourtBtn').classList.toggle('active', mode === 'court');
            
            // Update containers
            const matchContainer = document.getElementById('matchTechnicalContainer');
            const courtContainer = document.getElementById('courtModeContainer');
            
            if (mode === 'court') {
                matchContainer.classList.remove('active');
                courtContainer.classList.add('active');
                initCourtMode();
            } else {
                matchContainer.classList.add('active');
                courtContainer.classList.remove('active');
                
                // Handle match vs technical mode
                const matchPanel = document.getElementById('matchModePanel');
                const technicalPanel = document.getElementById('technicalModePanel');
                
                if (mode === 'match') {
                    isTechnicalMode = false;
                    matchPanel.style.display = 'block';
                    technicalPanel.style.display = 'none';
                } else if (mode === 'technical') {
                    isTechnicalMode = true;
                    matchPanel.style.display = 'none';
                    technicalPanel.style.display = 'block';
                    populateTechnicalLabels();
                    updateTaggedTechnicalLabels();
                }
            }
        }
        
        // Update court frame info display
        function updateCourtFrameInfo() {
            const courtVideoEl = document.getElementById('courtVideoPlayer');
            if (courtVideoEl && courtVideoEl.readyState >= 1) {
                const currentTime = courtVideoEl.currentTime;
                const frameNum = Math.floor(currentTime * courtFps);

                const frameEl = document.getElementById('courtFrameNumber');
                const timeEl = document.getElementById('courtCurrentTime');
                if (frameEl) frameEl.textContent = frameNum;
                if (timeEl) timeEl.textContent = currentTime.toFixed(2);

                // Update custom video controls
                updateCourtVideoControls();
            }
        }

        // Custom video control functions
        function toggleCourtPlayPause() {
            const courtVideoEl = document.getElementById('courtVideoPlayer');
            if (!courtVideoEl) return;

            if (courtVideoEl.paused) {
                courtVideoEl.play().catch(err => console.log('Play prevented:', err.message));
            } else {
                courtVideoEl.pause();
            }
        }

        function updateCourtVideoControls() {
            const courtVideoEl = document.getElementById('courtVideoPlayer');
            if (!courtVideoEl) return;

            // Update play/pause button
            const playIcon = document.querySelector('#courtPlayPauseBtn .play-icon');
            const pauseIcon = document.querySelector('#courtPlayPauseBtn .pause-icon');
            if (playIcon && pauseIcon) {
                playIcon.style.display = courtVideoEl.paused ? 'inline' : 'none';
                pauseIcon.style.display = courtVideoEl.paused ? 'none' : 'inline';
            }

            // Update seek bar
            const seekBar = document.getElementById('courtVideoSeek');
            if (seekBar && courtVideoEl.duration) {
                seekBar.value = (courtVideoEl.currentTime / courtVideoEl.duration) * 100;
            }

            // Update time display
            const timeDisplay = document.getElementById('courtTimeDisplay');
            if (timeDisplay) {
                const current = formatTime(courtVideoEl.currentTime);
                const total = formatTime(courtVideoEl.duration || 0);
                timeDisplay.textContent = `${current} / ${total}`;
            }
        }

        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Removed fullscreen mode - using larger video player layout instead

        // Toast timeout reference
        let shotToastTimeout = null;

        // Show shot toast - brief notification for each shot
        function showShotToast(shotNum, shotName) {
            const toast = document.getElementById('shotToast');
            if (!toast) return;

            // Clear any existing timeout
            if (shotToastTimeout) {
                clearTimeout(shotToastTimeout);
            }

            // Format shot name for display
            const displayName = formatShotName(shotName);

            // Set content
            toast.innerHTML = '';
            const numDiv = document.createElement('div');
            numDiv.className = 'toast-shot-num';
            numDiv.textContent = 'Shot ' + shotNum;
            const nameDiv = document.createElement('div');
            nameDiv.className = 'toast-shot-name';
            nameDiv.textContent = displayName;
            toast.appendChild(numDiv);
            toast.appendChild(nameDiv);

            // Show toast
            toast.classList.add('visible');

            // Hide after 1.5 seconds
            shotToastTimeout = setTimeout(() => {
                toast.classList.remove('visible');
            }, 1500);
        }

        // Legacy function - kept for compatibility with existing calls
        function updateShotTagsOverlay() {
            // No longer showing overlay - using toast notifications instead
        }

        function setCourtPlaybackSpeed() {
            const courtVideoEl = document.getElementById('courtVideoPlayer');
            const speedSelect = document.getElementById('courtSpeedSelect');
            if (courtVideoEl && speedSelect) {
                courtVideoEl.playbackRate = parseFloat(speedSelect.value);
            }
        }

        function setupCourtVideoControls() {
            const courtVideoEl = document.getElementById('courtVideoPlayer');
            const seekBar = document.getElementById('courtVideoSeek');

            if (!courtVideoEl || !seekBar) return;

            // Seek bar interaction
            seekBar.addEventListener('input', function() {
                if (courtVideoEl.duration) {
                    courtVideoEl.currentTime = (this.value / 100) * courtVideoEl.duration;
                }
            });

            // Video events
            courtVideoEl.addEventListener('play', updateCourtVideoControls);
            courtVideoEl.addEventListener('pause', updateCourtVideoControls);
            courtVideoEl.addEventListener('loadedmetadata', function() {
                updateCourtVideoControls();
                // Set seek bar max when video is loaded
                const seekBar = document.getElementById('courtVideoSeek');
                if (seekBar) seekBar.max = 100;
            });
        }

        // Initialize Court Mode
        function initCourtMode() {
            // Setup court video reference
            courtVideo = document.getElementById('courtVideoPlayer');

            // Setup custom video controls
            setupCourtVideoControls();

            // Setup player name inputs
            const p1Input = document.getElementById('p1NameInput');
            const p2Input = document.getElementById('p2NameInput');
            
            if (p1Input) {
                p1Input.addEventListener('change', updatePlayerNames);
                p1Input.addEventListener('input', updatePlayerNames);
            }
            if (p2Input) {
                p2Input.addEventListener('change', updatePlayerNames);
                p2Input.addEventListener('input', updatePlayerNames);
            }
            
            // Setup zone click handlers
            setupZoneClickHandlers();
            
            // Setup canvas click handlers
            setupCanvasClickHandlers();
            
            // Load saved calibration
            loadCalibration();
            
            // Update display
            updatePlayerNames();
            updateScoreDisplay();
            updateRallyLog();
            updateCalibrationStatus();
            
            // Load saved court data
            loadCourtData();
            
            // Set initial input mode
            setCourtInputMode(courtInputMode);
            
            // Video resize handler to redraw overlay
            const courtVideoEl = document.getElementById('courtVideoPlayer');
            if (courtVideoEl) {
                courtVideoEl.addEventListener('loadeddata', () => {
                    setTimeout(drawCourtOverlay, 100);
                });
                
                // Redraw overlay on window resize
                window.addEventListener('resize', () => {
                    if (isCalibrated) {
                        drawCourtOverlay();
                    }
                });
            }
        }
        
        // Setup canvas click handlers
        function setupCanvasClickHandlers() {
            const overlayCanvas = document.getElementById('courtOverlayCanvas');
            
            if (!overlayCanvas) return;
            
            overlayCanvas.addEventListener('click', handleCanvasClick);
            overlayCanvas.addEventListener('mousemove', handleCanvasMouseMove);
            overlayCanvas.addEventListener('mouseleave', () => {
                document.getElementById('coordDisplay').style.display = 'none';
            });
        }
        
        // Handle click on canvas overlay
        function handleCanvasClick(e) {
            if (!isCalibrated || courtInputMode !== 'canvas' || isCalibrating) return;

            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();

            const courtVideoEl = document.getElementById('courtVideoPlayer');
            if (!courtVideoEl || courtVideoEl.readyState < 2) {
                alert('Please load a video first!');
                return;
            }

            // If waiting for server, ignore
            if (waitingForServer) return;

            // If no rally in progress, prompt to start
            if (!rallyInProgress) {
                alert('Press Enter or click "New Rally" to start a rally first.');
                return;
            }
            
            // Get click position relative to canvas display
            const displayX = e.clientX - rect.left;
            const displayY = e.clientY - rect.top;
            
            // Scale to calibration dimensions (homography expects calibration-time coordinates)
            const scaleX = calibrationCanvasWidth / rect.width;
            const scaleY = calibrationCanvasHeight / rect.height;
            const pixelX = displayX * scaleX;
            const pixelY = displayY * scaleY;
            
            // Convert to court coordinates
            const courtCoords = videoToCourtCoords(pixelX, pixelY);
            if (!courtCoords) return;
            
            // Round to 10cm
            const x = roundTo10cm(courtCoords.x);
            const y = roundTo10cm(courtCoords.y);
            
            // Validate coordinates are within court bounds
            if (x < 0 || x > COURT_WIDTH || y < 0 || y > COURT_LENGTH) {
                showToast({ name: 'Click inside the court' }, false);
                return;
            }
            
            // Get zone from coordinates
            const zone = getZoneFromCoords(x, y);
            const player = y < NET_Y ? 'P2' : 'P1';

            // SERVE FLOW: Two-click (FROM zone then TO zone)
            if (isServing) {
                // First click: Select FROM zone (server position)
                if (!selectedFromZone) {
                    // Validate: must be on server's side
                    const serverSide = currentServer;
                    if (player !== serverSide) {
                        showToast({ name: 'Click on server\'s side' }, false);
                        return;
                    }
                    // Validate: zones 1-4 only for serve starting position
                    const zoneNum = parseInt(zone.replace(/[ab]/g, ''));
                    if (isNaN(zoneNum) || zoneNum < 1 || zoneNum > 4) {
                        showToast({ name: 'Serve from zones 1-4' }, false);
                        return;
                    }

                    // Set FROM zone and coordinates
                    selectedFromZone = zone;
                    fromCoords = { x, y };
                    fromMarker = { x: pixelX, y: pixelY };

                    // Update display
                    document.getElementById('fromZoneDisplay').textContent = formatZoneName(zone);
                    document.getElementById('fromZoneDisplay').classList.remove('pending');
                    document.getElementById('fromCoordsDisplay').textContent = `(${x.toFixed(1)}m, ${y.toFixed(1)}m)`;
                    document.getElementById('fromCoordsDisplay').style.display = 'inline';
                    document.getElementById('toZoneDisplay').textContent = 'Click serve landing...';
                    document.getElementById('toZoneDisplay').classList.add('pending');
                    updateCompactShotBar();

                    // Redraw overlay with FROM marker
                    drawCourtOverlay();
                    return;
                }

                // Second click: Select TO zone (serve landing)
                // Validate: must be on opponent's side
                const opponentSide = currentServer === 'P1' ? 'P2' : 'P1';
                if (player !== opponentSide) {
                    showToast({ name: 'Click on opponent\'s side' }, false);
                    return;
                }

                // Store coordinates and process serve landing
                toCoords = { x, y };
                toMarker = { x: pixelX, y: pixelY };
                processCanvasLandingZone(zone, player, x, y, pixelX, pixelY);
                return;
            }

            // REGULAR SHOT FLOW: Validate landing zone
            if (!isValidLandingZone(zone, player)) {
                showToast({ name: 'Invalid landing zone' }, false);
                return;
            }

            // Store coordinates and process landing
            toCoords = { x, y };
            toMarker = { x: pixelX, y: pixelY };

            // Process the landing zone with coordinates
            processCanvasLandingZone(zone, player, x, y, pixelX, pixelY);
        }
        
        // Process canvas landing zone click
        function processCanvasLandingZone(zone, player, courtX, courtY, pixelX, pixelY) {
            selectedToZone = zone;
            
            // Get trajectory (default or overridden)
            if (!trajectoryOverridden) {
                defaultTrajectory = getDefaultTrajectory(selectedFromZone, selectedToZone);
                currentTrajectory = defaultTrajectory;
            }

            // Use overridden shot type if set, otherwise infer from zones
            let shotType;
            if (overriddenShotType) {
                shotType = overriddenShotType;
                console.log('Using overridden shot type:', shotType);
            } else {
                shotType = inferShotTypeWithTrajectory(selectedFromZone, selectedToZone, currentTrajectory);
            }
            
            // Update display
            document.getElementById('toZoneDisplay').textContent = formatZoneName(selectedToZone);
            document.getElementById('toZoneDisplay').classList.remove('pending');
            document.getElementById('toCoordsDisplay').textContent = `(${courtX.toFixed(1)}m, ${courtY.toFixed(1)}m)`;
            document.getElementById('toCoordsDisplay').style.display = 'inline';

            document.getElementById('shotTypeDisplay').style.display = 'block';
            document.getElementById('inferredShotType').textContent = formatShotName(shotType);

            // Update trajectory display and compact bar
            updateTrajectoryDisplay();
            updateCompactShotBar();
            
            // Draw markers on canvas
            drawCourtOverlay();
            
            // Add the shot (includes trajectory)
            addCanvasCourtShot(shotType, courtX, courtY);
            
            // Determine next FROM zone and set up for next shot
            const nextFromZone = mapLandingToNextFrom(zone);
            setupNextCanvasShot(nextFromZone);
        }
        
        // Setup for next canvas shot
        function setupNextCanvasShot(fromZone) {
            // Switch hitter
            currentHitter = currentHitter === 'P1' ? 'P2' : 'P1';
            
            // Set FROM zone
            selectedFromZone = fromZone;
            selectedToZone = null;
            toCoords = null;
            toMarker = null;
            
            // Reset trajectory and shot override
            trajectoryOverridden = false;
            defaultTrajectory = 0;
            currentTrajectory = 0;
            overriddenShotType = null;
            courtComboBuffer = '';
            if (courtComboTimeout) {
                clearTimeout(courtComboTimeout);
                courtComboTimeout = null;
            }
            hideCourtComboIndicator();
            
            // Calculate FROM coordinates from zone center (approximate)
            const fromCoordApprox = getZoneCenterCoords(fromZone);
            fromCoords = fromCoordApprox;
            
            // Get pixel position for marker
            if (fromCoordApprox) {
                const pixelPos = courtToVideoCoords(fromCoordApprox.x, fromCoordApprox.y);
                if (pixelPos) {
                    fromMarker = pixelPos;
                }
            }
            
            // Update display
            document.getElementById('fromZoneDisplay').textContent = formatZoneName(selectedFromZone);
            document.getElementById('fromZoneDisplay').classList.remove('pending');
            if (fromCoords) {
                document.getElementById('fromCoordsDisplay').textContent = `(${fromCoords.x.toFixed(1)}m, ${fromCoords.y.toFixed(1)}m)`;
                document.getElementById('fromCoordsDisplay').style.display = 'inline';
            }
            
            document.getElementById('toZoneDisplay').textContent = 'Click on court...';
            document.getElementById('toZoneDisplay').classList.add('pending');
            document.getElementById('toCoordsDisplay').style.display = 'none';
            document.getElementById('shotTypeDisplay').style.display = 'none';

            // Update trajectory selector and compact bar
            updateTrajectorySelector();
            updateTrajectoryDisplay();
            updateCompactShotBar();

            // Redraw overlay with FROM marker
            drawCourtOverlay();
        }
        
        // Get approximate center coordinates for a zone
        function getZoneCenterCoords(zone) {
            const zoneNum = zone.replace(/[ab]/g, '').replace(/[ob]$/, '');
            const isP2Side = zone.includes('b');

            // Zone center X coordinates (FH on right, BH on left from P2 perspective)
            // New 6-zone system: 1=Front FH, 2=Front BH, 3=Mid FH, 4=Mid BH, 5=Back FH, 6=Back BH
            const zoneCentersX = {
                '1': COURT_WIDTH * 0.75,  // Front FH
                '2': COURT_WIDTH * 0.25,  // Front BH
                '3': COURT_WIDTH * 0.75,  // Mid FH
                '4': COURT_WIDTH * 0.25,  // Mid BH
                '5': COURT_WIDTH * 0.75,  // Back FH
                '6': COURT_WIDTH * 0.25   // Back BH
            };

            // Zone center Y coordinates (distance from P2's baseline)
            // Front: 0-2.5m from net, center at ~5.5m from baseline
            // Mid: 2.5-4.5m from net, center at ~3.5m from baseline
            // Back: 4.5-6.7m from net, center at ~1.1m from baseline
            const zoneCentersY = {
                '1': 5.5, '2': 5.5,  // Front (close to net)
                '3': 3.5, '4': 3.5,  // Mid
                '5': 1.1, '6': 1.1   // Back (close to baseline)
            };

            let x = zoneCentersX[zoneNum] || COURT_WIDTH / 2;
            let y = zoneCentersY[zoneNum] || NET_Y;

            // Adjust for P1/P2 side
            if (!isP2Side) {
                y = COURT_LENGTH - y;
                // X positions are already correct (FH=right for both players)
            }

            return { x, y };
        }
        
        // Add court shot with canvas data
        function addCanvasCourtShot(shotType, courtX, courtY) {
            const courtVideoEl = document.getElementById('courtVideoPlayer');
            if (!courtVideoEl || courtVideoEl.readyState < 2) return;
            
            const timestamp = courtVideoEl.currentTime;
            const frame = Math.floor(timestamp * courtFps);
            
            const shot = {
                game: currentGame,
                rally: currentRally,
                shotNum: currentShotNum + 1,
                frame: frame,
                timestamp: parseFloat(timestamp.toFixed(2)),
                server: currentServer,
                p1Score: p1Score,
                p2Score: p2Score,
                player: currentHitter,
                fromZone: selectedFromZone,
                fromX: fromCoords ? roundTo10cm(fromCoords.x) : null,
                fromY: fromCoords ? roundTo10cm(fromCoords.y) : null,
                toZone: selectedToZone,
                toX: roundTo10cm(courtX),
                toY: roundTo10cm(courtY),
                trajectory: currentTrajectory,
                shotType: shotType,
                rallyWinner: null
            };
            
            currentRallyShots.push(shot);
            courtAnnotations.push(shot);
            currentShotNum++;

            // Show shot toast notification
            showShotToast(currentShotNum, shotType);
            updateShotTagsOverlay();

            // Reset shot modifier states for next shot
            resetShotModifiers();

            // Show end rally buttons
            document.getElementById('p1WonBtn').style.display = 'inline-block';
            document.getElementById('p2WonBtn').style.display = 'inline-block';

            // Update rally log
            updateRallyLog();

            // Save data
            saveCourtData();

            // Show toast
            showToast({ name: shotType }, false);
        }

        // Handle mouse move on canvas
        function handleCanvasMouseMove(e) {
            if (!isCalibrated || courtInputMode !== 'canvas' || isCalibrating) {
                document.getElementById('coordDisplay').style.display = 'none';
                return;
            }

            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();

            // Get mouse position relative to canvas display
            const displayX = e.clientX - rect.left;
            const displayY = e.clientY - rect.top;

            // Set crosshair cursor for canvas
            canvas.style.cursor = 'crosshair';

            // Scale to calibration dimensions
            const scaleX = calibrationCanvasWidth / rect.width;
            const scaleY = calibrationCanvasHeight / rect.height;
            const pixelX = displayX * scaleX;
            const pixelY = displayY * scaleY;
            
            // Convert to court coordinates
            const courtCoords = videoToCourtCoords(pixelX, pixelY);
            if (!courtCoords) {
                document.getElementById('coordDisplay').style.display = 'none';
                return;
            }
            
            const x = roundTo10cm(courtCoords.x);
            const y = roundTo10cm(courtCoords.y);
            
            // Check if within bounds
            if (x < 0 || x > COURT_WIDTH || y < 0 || y > COURT_LENGTH) {
                document.getElementById('coordDisplay').style.display = 'none';
                return;
            }
            
            // Get zone
            const zone = getZoneFromCoords(x, y);
            
            // Update display
            document.getElementById('coordValue').textContent = `(${x.toFixed(1)}m, ${y.toFixed(1)}m)`;
            document.getElementById('zoneInfo').textContent = `Zone: ${formatZoneName(zone)}`;
            document.getElementById('coordDisplay').style.display = 'block';
        }
        
        function updatePlayerNames() {
            const p1Input = document.getElementById('p1NameInput');
            const p2Input = document.getElementById('p2NameInput');
            
            p1Name = p1Input ? p1Input.value || 'P1' : 'P1';
            p2Name = p2Input ? p2Input.value || 'P2' : 'P2';
            
            // Update all displays
            document.getElementById('p1NameDisplay').textContent = p1Name;
            document.getElementById('p2NameDisplay').textContent = p2Name;
            document.getElementById('scoreP1Name').textContent = p1Name;
            document.getElementById('scoreP2Name').textContent = p2Name;
            document.getElementById('serverModalP1Name').textContent = p1Name;
            document.getElementById('serverModalP2Name').textContent = p2Name;
            
            // Update P1 Won / P2 Won buttons (with 1 / 2 keyboard shortcuts)
            document.getElementById('p1WonBtn').textContent = `${p1Name} Won ( 1 )`;
            document.getElementById('p2WonBtn').textContent = `${p2Name} Won ( 2 )`;
        }
        
        function setupZoneClickHandlers() {
            const zones = document.querySelectorAll('.court-zone');
            zones.forEach(zone => {
                zone.addEventListener('click', () => handleZoneClick(zone));
            });
        }
        
        function handleZoneClick(zoneElement) {
            const zone = zoneElement.dataset.zone;
            const player = zoneElement.dataset.player;

            const courtVideoEl = document.getElementById('courtVideoPlayer');
            if (!courtVideoEl || courtVideoEl.readyState < 2) {
                alert('Please load a video first!');
                return;
            }

            // If waiting for server selection, ignore zone clicks
            if (waitingForServer) {
                return;
            }

            // If no rally in progress, prompt to start one
            if (!rallyInProgress) {
                alert('Press Enter or click "New Rally" to start a rally first.');
                return;
            }

            // SERVE FLOW: Two-click (FROM zone then TO zone)
            if (isServing) {
                // First click: Select FROM zone (server position)
                if (!selectedFromZone) {
                    // Validate: must be zones 1-4 on server's side
                    const serverSide = currentServer === 'P1' ? 'P1' : 'P2';
                    if (player !== serverSide) {
                        return; // Can only click on server's side
                    }
                    const zoneNum = parseInt(zone.replace(/[ab]/g, ''));
                    if (isNaN(zoneNum) || zoneNum < 1 || zoneNum > 4) {
                        return; // Only zones 1-4 are valid for serve FROM
                    }

                    selectedFromZone = zone;

                    // Update display
                    document.getElementById('fromZoneDisplay').textContent = formatZoneName(zone);
                    document.getElementById('fromZoneDisplay').classList.remove('pending');
                    document.getElementById('toZoneDisplay').textContent = 'Click serve landing...';
                    document.getElementById('toZoneDisplay').classList.add('pending');

                    // Highlight valid landing zones
                    highlightServeLandingZones(currentServer);
                    return;
                }

                // Second click: Select TO zone (serve landing)
                // Validate: must be on opponent's side
                const opponentSide = currentServer === 'P1' ? 'P2' : 'P1';
                if (player !== opponentSide) {
                    return; // Must land on opponent's side
                }

                // Process the serve
                processLandingZone(zone, player);
                return;
            }

            // REGULAR SHOT FLOW: One-click (FROM auto-set, just click TO zone)
            if (!isValidLandingZone(zone, player)) {
                return;
            }

            // Record the shot
            processLandingZone(zone, player);
        }
        
        // Check if a landing zone is valid for the current state (regular shots only)
        // Note: Serve validation is handled separately in handleZoneClick
        function isValidLandingZone(zone, player) {
            // Landing must be on opponent's court
            if (player === currentHitter) {
                return false;
            }

            // Regular shot - can land anywhere on opponent's court (zones 1-6)
            const zoneNum = parseInt(zone.replace(/[ab]/g, ''));
            if (isNaN(zoneNum) || zoneNum < 1 || zoneNum > 6) {
                return false;
            }

            return true;
        }
        
        // Process a landing zone click (main one-click flow)
        function processLandingZone(zone, player) {
            selectedToZone = zone;

            // Use overridden shot type if set, otherwise infer from zones
            let shotType;
            if (overriddenShotType) {
                shotType = overriddenShotType;
                console.log('Using overridden shot type:', shotType);
            } else {
                shotType = inferShotType(selectedFromZone, selectedToZone);
            }
            
            // Update display
            document.getElementById('toZoneDisplay').textContent = formatZoneName(selectedToZone);
            document.getElementById('toZoneDisplay').classList.remove('pending');
            document.getElementById('shotTypeDisplay').style.display = 'block';
            document.getElementById('inferredShotType').textContent = formatShotName(shotType);
            
            // Highlight the landing zone
            clearZoneHighlights();
            const fromEl = document.querySelector(`[data-zone="${selectedFromZone.replace(/[ob](?=[ab]$)/, '')}"]`);
            if (fromEl) fromEl.classList.add('selected-from');
            const toEl = document.querySelector(`[data-zone="${zone}"]`);
            if (toEl) toEl.classList.add('selected-to');
            
            // Add the shot
            addCourtShot(shotType);
            
            // Determine next FROM zone based on landing and set up for next shot
            const nextFromZone = mapLandingToNextFrom(zone);
            setupNextShot(nextFromZone);
        }
        
        // Map landing zone to the next hitter's FROM zone
        function mapLandingToNextFrom(landingZone) {
            // Landing zone becomes the FROM zone for the next shot (zones 1-6)
            return landingZone;
        }
        
        // Set up for the next shot after current shot is recorded
        function setupNextShot(fromZone) {
            // Switch hitter
            currentHitter = currentHitter === 'P1' ? 'P2' : 'P1';

            // Set the FROM zone for next shot
            selectedFromZone = fromZone;
            selectedToZone = null;

            // Reset shot override
            overriddenShotType = null;
            courtComboBuffer = '';
            if (courtComboTimeout) {
                clearTimeout(courtComboTimeout);
                courtComboTimeout = null;
            }
            hideCourtComboIndicator();

            // Update display
            document.getElementById('fromZoneDisplay').textContent = formatZoneName(selectedFromZone);
            document.getElementById('fromZoneDisplay').classList.remove('pending');
            document.getElementById('toZoneDisplay').textContent = 'Click landing...';
            document.getElementById('toZoneDisplay').classList.add('pending');
            document.getElementById('shotTypeDisplay').style.display = 'none';
            
            // Highlight FROM zone and valid landing zones
            clearZoneHighlights();
            const fromEl = document.querySelector(`[data-zone="${fromZone.replace(/[ob](?=[ab]$)/, '')}"]`);
            if (fromEl) fromEl.classList.add('selected-from');
            highlightValidLandingZones();
        }
        
        // Highlight all valid landing zones for current state
        function highlightValidLandingZones() {
            const opponentSide = currentHitter === 'P1' ? 'P2' : 'P1';
            
            document.querySelectorAll('.court-zone').forEach(zoneEl => {
                const zone = zoneEl.dataset.zone;
                const player = zoneEl.dataset.player;
                
                if (isValidLandingZone(zone, player)) {
                    zoneEl.classList.add('valid-target');
                } else {
                    zoneEl.classList.add('disabled');
                }
            });
        }
        
        function inferShotType(fromZone, toZone) {
            // Use the trajectory-aware inference with current trajectory
            return inferShotTypeWithTrajectory(fromZone, toZone, currentTrajectory);
        }
        
        function addCourtShot(shotType) {
            const courtVideoEl = document.getElementById('courtVideoPlayer');
            if (!courtVideoEl || courtVideoEl.readyState < 2) return;
            
            const timestamp = courtVideoEl.currentTime;
            const frame = Math.floor(timestamp * courtFps);
            
            // Get zone center coordinates for CSV export
            const fromCoordsZone = getZoneCenterCoords(selectedFromZone);
            const toCoordsZone = getZoneCenterCoords(selectedToZone);

            const shot = {
                game: currentGame,
                rally: currentRally,
                shotNum: currentShotNum + 1,
                frame: frame,
                timestamp: parseFloat(timestamp.toFixed(2)),
                server: currentServer,
                p1Score: p1Score,
                p2Score: p2Score,
                player: currentHitter,
                fromZone: selectedFromZone,
                fromX: fromCoordsZone ? roundTo10cm(fromCoordsZone.x) : null,
                fromY: fromCoordsZone ? roundTo10cm(fromCoordsZone.y) : null,
                toZone: selectedToZone,
                toX: toCoordsZone ? roundTo10cm(toCoordsZone.x) : null,
                toY: toCoordsZone ? roundTo10cm(toCoordsZone.y) : null,
                trajectory: currentTrajectory,
                shotType: shotType,
                rallyWinner: null
            };

            currentRallyShots.push(shot);
            courtAnnotations.push(shot);
            currentShotNum++;

            // Show shot toast notification
            showShotToast(currentShotNum, shotType);
            updateShotTagsOverlay();

            // Reset shot modifier states for next shot
            resetShotModifiers();

            // Show end rally buttons
            document.getElementById('p1WonBtn').style.display = 'inline-block';
            document.getElementById('p2WonBtn').style.display = 'inline-block';

            // Update rally log
            updateRallyLog();

            // Save data
            saveCourtData();

            // Show toast
            showToast({ name: shotType }, false);

            // Note: hitter switching and next shot setup is handled by processLandingZone/setupNextShot
        }


        function clearZoneHighlights() {
            document.querySelectorAll('.court-zone').forEach(zone => {
                zone.classList.remove('selected-from', 'selected-to', 'valid-target', 'disabled', 'highlight');
            });
        }
        
        function formatZoneName(zone) {
            if (!zone) return '-';
            const num = zone.replace(/[ab]/g, '');
            const side = zone.endsWith('a') ? 'P1' : 'P2';

            // Simplified zone names: Front/Mid/Back with FH/BH
            const zoneNames = {
                '1': 'Front FH',
                '2': 'Front BH',
                '3': 'Mid FH',
                '4': 'Mid BH',
                '5': 'Back FH',
                '6': 'Back BH',
            };

            const name = zoneNames[num] || num;
            return `${name} (${side})`;
        }

        // Sync compact shot bar with current shot state
        function updateCompactShotBar() {
            const compactFrom = document.getElementById('compactFromZone');
            const compactTo = document.getElementById('compactToZone');
            const compactShotType = document.getElementById('compactShotType');
            const compactShotSegment = document.getElementById('compactShotTypeSegment');

            if (compactFrom) {
                const fromText = selectedFromZone ? formatZoneName(selectedFromZone) : '-';
                compactFrom.textContent = fromText;
                compactFrom.classList.toggle('pending', !selectedFromZone);
            }

            if (compactTo) {
                const toText = selectedToZone ? formatZoneName(selectedToZone) : '-';
                compactTo.textContent = toText;
                compactTo.classList.toggle('pending', !selectedToZone);
            }

            // Show shot type if both zones are selected
            if (compactShotSegment && compactShotType) {
                if (selectedFromZone && selectedToZone) {
                    const shotType = inferShotTypeWithTrajectory(selectedFromZone, selectedToZone, currentTrajectory);
                    compactShotType.textContent = formatShotName(shotType);
                    compactShotSegment.style.display = 'flex';
                } else {
                    compactShotSegment.style.display = 'none';
                }
            }

            // Update trajectory button states
            document.querySelectorAll('.compact-shot-bar .traj-btn').forEach(btn => {
                const traj = parseInt(btn.dataset.traj);
                btn.classList.toggle('active', traj === currentTrajectory);
            });
        }

        // Rally Management
        function startNewRally() {
            if (rallyInProgress && currentRallyShots.length > 0) {
                if (!confirm('Rally in progress. Discard and start new?')) {
                    return;
                }
            }
            
            // Reset rally state
            currentRallyShots = [];
            currentShotNum = 0;
            selectedFromZone = null;
            selectedToZone = null;
            rallyInProgress = false;
            
            // Clear displays
            clearZoneHighlights();
            document.getElementById('fromZoneDisplay').textContent = '-';
            document.getElementById('fromZoneDisplay').classList.add('pending');
            document.getElementById('toZoneDisplay').textContent = '-';
            document.getElementById('toZoneDisplay').classList.add('pending');
            document.getElementById('shotTypeDisplay').style.display = 'none';
            
            // Hide end rally buttons
            document.getElementById('p1WonBtn').style.display = 'none';
            document.getElementById('p2WonBtn').style.display = 'none';
            
            // Show server selection modal
            waitingForServer = true;
            document.getElementById('serverModal').classList.add('show');

            // Update overlay
            updateShotTagsOverlay();
        }
        
        function selectServer(server) {
            currentServer = server;
            currentHitter = server;
            waitingForServer = false;
            rallyInProgress = true;
            isServing = true; // First shot is a serve

            // Hide modal
            document.getElementById('serverModal').classList.remove('show');

            // Reset selection state - annotator will click FROM and TO zones
            selectedFromZone = null;
            selectedToZone = null;
            fromCoords = null;
            toCoords = null;
            fromMarker = null;
            toMarker = null;

            // Reset trajectory for serve
            trajectoryOverridden = false;
            defaultTrajectory = -1; // Serves are typically downward
            currentTrajectory = -1;

            // Update server indicator
            const serverName = server === 'P1' ? p1Name : p2Name;
            document.getElementById('serverIndicator').textContent = `${serverName} serving`;

            // Highlight server's score
            document.getElementById('scoreP1').classList.toggle('serving', server === 'P1');
            document.getElementById('scoreP2').classList.toggle('serving', server === 'P2');

            // Update display - waiting for FROM zone click
            document.getElementById('fromZoneDisplay').textContent = 'Click server position...';
            document.getElementById('fromZoneDisplay').classList.add('pending');
            document.getElementById('fromCoordsDisplay').style.display = 'none';

            document.getElementById('toZoneDisplay').textContent = '-';
            document.getElementById('toZoneDisplay').classList.add('pending');
            document.getElementById('toCoordsDisplay').style.display = 'none';

            // Update trajectory display
            updateTrajectorySelector();
            updateTrajectoryDisplay();

            // Highlight valid serve FROM zones (1-4 on server's side)
            if (isCalibrated && courtInputMode === 'canvas') {
                drawCourtOverlay();
            } else {
                highlightServeFromZones(server);
            }
        }
        
        // Highlight valid zones for serve FROM position (zones 1-4 on server's side)
        function highlightServeFromZones(server) {
            clearZoneHighlights();

            const serverSide = server === 'P1' ? 'a' : 'b';

            // Valid FROM zones for serve: zones 1-4 on server's side
            const validFromZones = ['1', '2', '3', '4'].map(z => z + serverSide);

            document.querySelectorAll('.court-zone').forEach(zone => {
                const zoneId = zone.dataset.zone;
                if (validFromZones.includes(zoneId)) {
                    zone.classList.add('valid-target');
                } else {
                    zone.classList.add('disabled');
                }
            });
        }

        // Highlight valid zones for serve landing (all zones 1-6 on opponent's side)
        function highlightServeLandingZones(server) {
            clearZoneHighlights();

            const opponentSide = server === 'P1' ? 'b' : 'a';

            // Valid landing zones for serve: all zones 1-6 on opponent's side
            const validLandingZones = ['1', '2', '3', '4', '5', '6'].map(z => z + opponentSide);

            document.querySelectorAll('.court-zone').forEach(zone => {
                const zoneId = zone.dataset.zone;
                if (validLandingZones.includes(zoneId)) {
                    zone.classList.add('valid-target');
                } else {
                    zone.classList.add('disabled');
                }
            });

            // Also highlight the selected FROM zone
            if (selectedFromZone) {
                const fromEl = document.querySelector(`[data-zone="${selectedFromZone}"]`);
                if (fromEl) {
                    fromEl.classList.remove('disabled');
                    fromEl.classList.add('selected-from');
                }
            }
        }
        
        function endRally(winner) {
            if (currentRallyShots.length === 0) {
                alert('No shots in this rally!');
                return;
            }
            
            // Mark all shots in this rally with the winner
            currentRallyShots.forEach(shot => {
                shot.rallyWinner = winner;
            });
            
            // Update in main array
            courtAnnotations.forEach(ann => {
                if (ann.game === currentGame && ann.rally === currentRally) {
                    ann.rallyWinner = winner;
                }
            });
            
            // Update score
            if (winner === 'P1') {
                p1Score++;
            } else {
                p2Score++;
            }
            
            // Next rally
            currentRally++;
            rallyInProgress = false;
            currentRallyShots = [];
            currentShotNum = 0;
            
            // Update displays
            updateScoreDisplay();
            updateRallyLog();
            updateShotTagsOverlay();
            clearZoneHighlights();
            
            // Hide end rally buttons
            document.getElementById('p1WonBtn').style.display = 'none';
            document.getElementById('p2WonBtn').style.display = 'none';
            
            // Update server indicator
            document.getElementById('serverIndicator').textContent = 'Press Enter for new rally';
            document.getElementById('scoreP1').classList.remove('serving');
            document.getElementById('scoreP2').classList.remove('serving');
            
            // Save data
            saveCourtData();
        }

        // Undo the last rally winner (revert to previous rally state)
        function undoLastRallyWinner() {
            // Can't undo if we're in the middle of a rally
            if (rallyInProgress) {
                alert('Cannot undo while rally is in progress. Finish or cancel current rally first.');
                return;
            }

            // Can't undo if we're at rally 1 with no completed rallies
            if (currentRally <= 1 && !courtAnnotations.some(a => a.game === currentGame && a.rallyWinner)) {
                alert('No completed rally to undo.');
                return;
            }

            // Find the last completed rally
            const lastRallyNum = currentRally - 1;
            if (lastRallyNum < 1) {
                alert('No rally to undo.');
                return;
            }

            // Get all shots from the last rally
            const lastRallyShots = courtAnnotations.filter(
                a => a.game === currentGame && a.rally === lastRallyNum
            );

            if (lastRallyShots.length === 0) {
                alert('No shots found in last rally.');
                return;
            }

            // Get the winner that was recorded
            const previousWinner = lastRallyShots[0].rallyWinner;
            if (!previousWinner) {
                alert('Last rally has no winner recorded.');
                return;
            }

            if (!confirm(`Undo rally ${lastRallyNum}? (${previousWinner} won)\nThis will revert the score and reopen the rally.`)) {
                return;
            }

            // Revert score
            if (previousWinner === 'P1') {
                p1Score = Math.max(0, p1Score - 1);
            } else {
                p2Score = Math.max(0, p2Score - 1);
            }

            // Remove winner from all shots in that rally
            courtAnnotations.forEach(ann => {
                if (ann.game === currentGame && ann.rally === lastRallyNum) {
                    ann.rallyWinner = null;
                }
            });

            // Restore rally state
            currentRally = lastRallyNum;
            currentRallyShots = lastRallyShots.map(s => ({ ...s, rallyWinner: null }));
            currentShotNum = currentRallyShots.length;
            rallyInProgress = true;

            // Set up current hitter and zones based on last shot
            if (currentRallyShots.length > 0) {
                const lastShot = currentRallyShots[currentRallyShots.length - 1];
                currentHitter = lastShot.player === 'P1' ? 'P2' : 'P1';
                selectedFromZone = mapLandingToNextFrom(lastShot.toZone);
                selectedToZone = null;
            }

            // Update displays
            updateScoreDisplay();
            updateRallyLog();
            updateCompactShotBar();

            // Show end rally buttons
            document.getElementById('p1WonBtn').style.display = 'inline-block';
            document.getElementById('p2WonBtn').style.display = 'inline-block';

            document.getElementById('serverIndicator').textContent = 'Rally reopened - select winner';

            saveCourtData();
            showToast({ name: `Rally ${lastRallyNum} reopened` }, true);
        }

        function undoCourtShot() {
            if (currentRallyShots.length === 0) {
                // No shots in current rally
                if (courtAnnotations.length === 0) {
                    return;
                }
                alert('Cannot undo previous rally. Use Cancel to discard current rally.');
                return;
            }
            
            // Remove last shot from current rally
            const lastShot = currentRallyShots.pop();
            courtAnnotations.pop();
            currentShotNum--;
            
            // Restore state to before this shot
            currentHitter = lastShot.player;
            selectedFromZone = lastShot.fromZone;
            selectedToZone = null;

            // Update displays
            if (currentRallyShots.length === 0) {
                // Back to serve state
                document.getElementById('p1WonBtn').style.display = 'none';
                document.getElementById('p2WonBtn').style.display = 'none';
                
                const serverScore = currentServer === 'P1' ? p1Score : p2Score;
                const isEven = serverScore % 2 === 0;
                
                document.getElementById('fromZoneDisplay').textContent = `Serve (${isEven ? 'Even' : 'Odd'})`;
                document.getElementById('fromZoneDisplay').classList.remove('pending');
                document.getElementById('toZoneDisplay').textContent = 'Click serve landing...';
                document.getElementById('toZoneDisplay').classList.add('pending');
                document.getElementById('shotTypeDisplay').style.display = 'none';
                
                highlightServeLandingZones(currentServer, isEven);
            } else {
                // Restore to previous shot's landing as FROM
                const prevShot = currentRallyShots[currentRallyShots.length - 1];
                const fromZone = mapLandingToNextFrom(prevShot.toZone);
                
                document.getElementById('fromZoneDisplay').textContent = formatZoneName(fromZone);
                document.getElementById('fromZoneDisplay').classList.remove('pending');
                document.getElementById('toZoneDisplay').textContent = 'Click landing...';
                document.getElementById('toZoneDisplay').classList.add('pending');
                document.getElementById('shotTypeDisplay').style.display = 'none';
                
                selectedFromZone = fromZone;
                clearZoneHighlights();
                highlightValidLandingZones();
            }
            
            updateRallyLog();
            updateShotTagsOverlay();
            saveCourtData();
        }

        function cancelCurrentShot() {
            if (!rallyInProgress) {
                return;
            }
            
            // If at start of rally (no shots yet), reset to serve state
            if (currentShotNum === 0) {
                const serverScore = currentServer === 'P1' ? p1Score : p2Score;
                const isEven = serverScore % 2 === 0;
                
                selectedFromZone = isEven ? 
                    (currentServer === 'P1' ? 'Sa-E' : 'Sb-E') : 
                    (currentServer === 'P1' ? 'Sa-O' : 'Sb-O');
                selectedToZone = null;
                
                document.getElementById('fromZoneDisplay').textContent = `Serve (${isEven ? 'Even' : 'Odd'})`;
                document.getElementById('fromZoneDisplay').classList.remove('pending');
                document.getElementById('toZoneDisplay').textContent = 'Click serve landing...';
                document.getElementById('toZoneDisplay').classList.add('pending');
                document.getElementById('shotTypeDisplay').style.display = 'none';
                
                highlightServeLandingZones(currentServer, isEven);
            } else {
                // Reset to current state (waiting for landing)
                const lastShot = currentRallyShots[currentRallyShots.length - 1];
                const fromZone = mapLandingToNextFrom(lastShot.toZone);
                selectedFromZone = fromZone;
                selectedToZone = null;
                
                document.getElementById('fromZoneDisplay').textContent = formatZoneName(fromZone);
                document.getElementById('fromZoneDisplay').classList.remove('pending');
                document.getElementById('toZoneDisplay').textContent = 'Click landing...';
                document.getElementById('toZoneDisplay').classList.add('pending');
                document.getElementById('shotTypeDisplay').style.display = 'none';
                
                clearZoneHighlights();
                highlightValidLandingZones();
            }
        }
        
        // Score and Display
        function updateScoreDisplay() {
            document.getElementById('scoreP1').textContent = p1Score;
            document.getElementById('scoreP2').textContent = p2Score;
            document.getElementById('currentGameNum').textContent = currentGame;
            document.getElementById('currentRallyNum').textContent = currentRally;
        }
        
        function updateRallyLog() {
            const container = document.getElementById('rallyLogContent');
            const filterSelect = document.getElementById('shotTypeFilter');
            const shotFilter = filterSelect ? filterSelect.value : '';

            // Helper to check if shot matches filter
            function shotMatchesFilter(shot, filter) {
                if (!filter) return true;
                const shotType = (shot.shotType || '').toLowerCase();
                // Handle serve filter
                if (filter === 'serve') {
                    return shotType.includes('serve');
                }
                // Remove prefix and check for match
                const baseType = shotType.replace(/^(forehand_|backhand_|overhead_)/, '');
                return baseType === filter || baseType.startsWith(filter);
            }

            // Group annotations by rally
            const rallies = {};
            courtAnnotations.forEach(ann => {
                const key = `${ann.game}-${ann.rally}`;
                if (!rallies[key]) {
                    rallies[key] = {
                        game: ann.game,
                        rally: ann.rally,
                        shots: [],
                        allShots: [],
                        winner: ann.rallyWinner,
                        server: ann.server
                    };
                }
                rallies[key].allShots.push(ann);
                if (shotMatchesFilter(ann, shotFilter)) {
                    rallies[key].shots.push(ann);
                }
                if (ann.rallyWinner) {
                    rallies[key].winner = ann.rallyWinner;
                }
            });

            // Add current rally if in progress
            if (rallyInProgress && currentRallyShots.length > 0) {
                const key = `${currentGame}-${currentRally}`;
                const filteredShots = currentRallyShots.filter(s => shotMatchesFilter(s, shotFilter));
                rallies[key] = {
                    game: currentGame,
                    rally: currentRally,
                    shots: filteredShots,
                    allShots: currentRallyShots,
                    winner: null,
                    server: currentServer,
                    current: true
                };
            }

            // Filter out rallies with no matching shots when filter is active
            let rallyKeys = Object.keys(rallies);
            if (shotFilter) {
                rallyKeys = rallyKeys.filter(key => rallies[key].shots.length > 0);
            }

            rallyKeys = rallyKeys.sort((a, b) => {
                const [gA, rA] = a.split('-').map(Number);
                const [gB, rB] = b.split('-').map(Number);
                if (gA !== gB) return gB - gA;
                return rB - rA;
            });

            if (rallyKeys.length === 0) {
                const emptyMsg = shotFilter ?
                    `No rallies contain ${shotFilter} shots.` :
                    'No rallies yet. Press Enter to start a new rally.';
                container.innerHTML = `<div class="empty-state">${emptyMsg}</div>`;
                return;
            }

            let html = '';
            rallyKeys.forEach(key => {
                const rally = rallies[key];
                const currentClass = rally.current ? ' current' : '';
                const winnerBadge = rally.winner ?
                    `<span class="rally-winner">${rally.winner === 'P1' ? p1Name : p2Name} Won</span>` :
                    (rally.current ? '<span class="rally-winner" style="background: #f39c12;">In Progress</span>' : '');
                const filterInfo = shotFilter ? ` <span style="font-size: 10px; color: #888;">(${rally.shots.length}/${rally.allShots.length})</span>` : '';

                html += `
                    <div class="rally-entry${currentClass}">
                        <div class="rally-header">
                            <span>Game ${rally.game} | Rally ${rally.rally}${filterInfo}</span>
                            ${winnerBadge}
                        </div>
                        <div class="rally-shots">
                `;
                
                rally.shots.forEach((shot, idx) => {
                    const playerName = shot.player === 'P1' ? p1Name : p2Name;
                    html += `
                        <div class="rally-shot">
                            <span class="shot-num">${idx + 1}.</span>
                            <span class="shot-player">${playerName}:</span>
                            <span class="shot-zones">${formatZoneName(shot.fromZone)} ‚Üí ${formatZoneName(shot.toZone)}</span>
                            <span class="shot-type">${formatShotName(shot.shotType)}</span>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            });
            
            container.innerHTML = html;
        }
        
        // Game Management
        function startNewGame() {
            if (courtAnnotations.some(a => a.game === currentGame)) {
                currentGame++;
            }
            p1Score = 0;
            p2Score = 0;
            currentRally = 1;
            rallyInProgress = false;
            currentRallyShots = [];
            
            updateScoreDisplay();
            updateRallyLog();
            saveCourtData();
        }
        
        function endCurrentGame() {
            const winner = p1Score > p2Score ? p1Name : (p2Score > p1Score ? p2Name : 'Tie');
            alert(`Game ${currentGame} ended. Winner: ${winner} (${p1Score} - ${p2Score})`);
            startNewGame();
        }
        
        // FPS
        function setCourtFps() {
            const input = document.getElementById('courtFpsInput');
            const value = parseFloat(input.value);
            if (!isNaN(value) && value > 0) {
                courtFps = value;
                courtFrameRate = 1 / courtFps;
            }
        }
        
        // Data Management
        function saveCourtData() {
            const data = {
                annotations: courtAnnotations,
                currentGame,
                currentRally,
                p1Score,
                p2Score,
                p1Name,
                p2Name,
                p1Hand,
                p2Hand
            };
            localStorage.setItem('courtPositionData', JSON.stringify(data));
        }
        
        function loadCourtData() {
            const saved = localStorage.getItem('courtPositionData');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    courtAnnotations = data.annotations || [];
                    currentGame = data.currentGame || 1;
                    currentRally = data.currentRally || 1;
                    p1Score = data.p1Score || 0;
                    p2Score = data.p2Score || 0;
                    p1Name = data.p1Name || 'P1';
                    p2Name = data.p2Name || 'P2';
                    p1Hand = data.p1Hand || 'right';
                    p2Hand = data.p2Hand || 'right';
                    
                    // Update inputs
                    const p1Input = document.getElementById('p1NameInput');
                    const p2Input = document.getElementById('p2NameInput');
                    if (p1Input) p1Input.value = p1Name;
                    if (p2Input) p2Input.value = p2Name;
                    
                    updatePlayerNames();
                    updateScoreDisplay();
                    updateRallyLog();
                } catch (e) {
                    console.error('Error loading court data:', e);
                }
            }
        }
        
        function clearCourtData(clearCalibration = false) {
            const msg = clearCalibration ?
                'Clear ALL court data including calibration?' :
                'Clear court position data? (Calibration will be kept)';
            if (!confirm(msg)) return;

            courtAnnotations = [];
            currentGame = 1;
            currentRally = 1;
            p1Score = 0;
            p2Score = 0;
            currentShotNum = 0;
            currentRallyShots = [];
            rallyInProgress = false;
            selectedFromZone = null;
            selectedToZone = null;

            clearZoneHighlights();
            updateScoreDisplay();
            updateRallyLog();
            updateShotTagsOverlay();

            document.getElementById('p1WonBtn').style.display = 'none';
            document.getElementById('p2WonBtn').style.display = 'none';
            document.getElementById('serverIndicator').textContent = 'Press Enter for new rally';

            localStorage.removeItem('courtPositionData');

            if (clearCalibration) {
                localStorage.removeItem('courtCalibration');
                calibrationPoints = {};
                isCalibrated = false;
                homographyMatrix = null;
                document.getElementById('calibrateBtn').textContent = 'Calibrate';
                document.getElementById('calibrateBtn').classList.remove('calibrated');
            }
        }

        function clearAllStoredData() {
            if (!confirm('Clear ALL stored data?\n\n‚Ä¢ Court annotations\n‚Ä¢ Court calibration\n‚Ä¢ Match annotations\n\nThis cannot be undone!')) return;

            // Clear Court Position data
            localStorage.removeItem('courtPositionData');
            localStorage.removeItem('courtCalibration');

            // Clear Match annotations
            localStorage.removeItem('badmintonAnnotations');

            // Reset Court mode state
            courtAnnotations = [];
            calibrationPoints = {};
            isCalibrated = false;
            homographyMatrix = null;
            currentGame = 1;
            currentRally = 1;
            p1Score = 0;
            p2Score = 0;
            currentShotNum = 0;
            currentRallyShots = [];
            rallyInProgress = false;

            // Reset Match mode state
            annotations = [];
            lastShot = null;
            recentShotsList = [];

            // Update displays
            if (currentMode === 'court') {
                clearZoneHighlights();
                updateScoreDisplay();
                updateRallyLog();
                updateShotTagsOverlay();
                document.getElementById('calibrateBtn').textContent = 'Calibrate';
                document.getElementById('calibrateBtn').classList.remove('calibrated');
            } else {
                updateAnnotationsDisplay();
            }

            alert('All stored data cleared.');
        }
        
        // Export
        function exportCourtCSV() {
            if (courtAnnotations.length === 0) {
                alert('No court annotations to export!');
                return;
            }

            let csv = 'id,game,frame,timestamp,from_zone,from_x,from_y,to_zone,to_x,to_y,trajectory,shot_type\n';

            courtAnnotations.forEach((ann, idx) => {
                const fromX = ann.fromX !== null && ann.fromX !== undefined ? ann.fromX.toFixed(1) : '';
                const fromY = ann.fromY !== null && ann.fromY !== undefined ? ann.fromY.toFixed(1) : '';
                const toX = ann.toX !== null && ann.toX !== undefined ? ann.toX.toFixed(1) : '';
                const toY = ann.toY !== null && ann.toY !== undefined ? ann.toY.toFixed(1) : '';
                const traj = ann.trajectory !== null && ann.trajectory !== undefined ? ann.trajectory : '';

                csv += `${idx + 1},${ann.game},${ann.frame},${ann.timestamp},${ann.fromZone},${fromX},${fromY},${ann.toZone},${toX},${toY},${traj},${ann.shotType}\n`;
            });
            
            // Generate filename
            let filename = 'court_annotations.csv';
            if (videoFileName) {
                filename = `${videoFileName}_court.csv`;
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function exportCourtJSON() {
            if (courtAnnotations.length === 0) {
                alert('No court annotations to export!');
                return;
            }
            
            const data = {
                match: {
                    p1Name,
                    p2Name,
                    p1Hand,
                    p2Hand
                },
                annotations: courtAnnotations
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'court_annotations.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Import Court CSV
        function importCourtCSV(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const lines = text.trim().split('\n');

                if (lines.length < 2) {
                    alert('CSV file is empty or has no data rows.');
                    input.value = '';
                    return;
                }

                // Parse header
                const header = lines[0].split(',');
                const expectedHeader = ['id', 'game', 'frame', 'timestamp', 'from_zone', 'from_x', 'from_y', 'to_zone', 'to_x', 'to_y', 'trajectory', 'shot_type'];

                // Validate header
                if (header.length < expectedHeader.length) {
                    alert('Invalid CSV format. Expected columns: ' + expectedHeader.join(', '));
                    input.value = '';
                    return;
                }

                // Clear existing data
                courtAnnotations = [];

                // Parse data rows
                let maxGame = 1;
                let maxRally = 0;

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const values = line.split(',');

                    const ann = {
                        game: parseInt(values[1]) || 1,
                        rally: 0, // Will be computed
                        shotNum: 0, // Will be computed
                        player: null, // Not in CSV, will need to infer
                        frame: parseInt(values[2]) || 0,
                        timestamp: parseFloat(values[3]) || 0,
                        fromZone: values[4] || '',
                        fromX: values[5] ? parseFloat(values[5]) : null,
                        fromY: values[6] ? parseFloat(values[6]) : null,
                        toZone: values[7] || '',
                        toX: values[8] ? parseFloat(values[8]) : null,
                        toY: values[9] ? parseFloat(values[9]) : null,
                        trajectory: values[10] !== '' ? parseInt(values[10]) : 0,
                        shotType: values[11] || '',
                        rallyWinner: null
                    };

                    if (ann.game > maxGame) maxGame = ann.game;

                    courtAnnotations.push(ann);
                }

                // Update game state
                currentGame = maxGame;
                currentRally = maxRally + 1;
                currentShotNum = 0;
                currentRallyShots = [];
                rallyInProgress = false;

                // Update displays
                updateGameDisplay();
                updateScoreDisplay();
                updateRallyLog();
                updateShotTagsOverlay();
                saveCourtData();

                alert(`Imported ${courtAnnotations.length} annotations from CSV.`);
                input.value = '';
            };

            reader.readAsText(file);
        }

        // Keyboard shortcuts for Court Mode
        document.addEventListener('keydown', function(e) {
            if (currentMode !== 'court') return;
            
            const tagName = e.target.tagName;
            const isInput = tagName === 'INPUT' || tagName === 'TEXTAREA';
            
            // Enter - New Rally
            if (e.key === 'Enter' && !isInput) {
                e.preventDefault();
                if (waitingForServer) return;
                if (isCalibrating) return;
                startNewRally();
                return;
            }
            
            // 1 or 2 - End rally (P1 won or P2 won) OR Server selection
            if ((e.key === '1' || e.key === '2') && !isInput) {
                e.preventDefault();

                // Server selection takes priority
                if (waitingForServer) {
                    if (e.key === '1') selectServer('P1');
                    else if (e.key === '2') selectServer('P2');
                    return;
                }

                // End rally - P1 won (1) or P2 won (2)
                if (rallyInProgress && currentRallyShots.length > 0) {
                    endRally(e.key === '1' ? 'P1' : 'P2');
                }
                return;
            }
            
            // Escape - Cancel
            if (e.key === 'Escape') {
                // Clear any pending combo first
                if (courtComboBuffer) {
                    courtComboBuffer = '';
                    overriddenShotType = null;
                    if (courtComboTimeout) {
                        clearTimeout(courtComboTimeout);
                        courtComboTimeout = null;
                    }
                    hideCourtComboIndicator();
                    return;
                }
                if (isCalibrating) {
                    document.getElementById('calibrationOverlay').style.display = 'none';
                    isCalibrating = false;
                    return;
                }
                if (waitingForServer) {
                    document.getElementById('serverModal').classList.remove('show');
                    waitingForServer = false;
                } else {
                    cancelCurrentShot();
                }
                return;
            }
            
            // Backspace - Undo
            if (e.key === 'Backspace' && !isInput) {
                e.preventDefault();
                undoCourtShot();
                return;
            }
            
            // Keyboard controls for court mode
            if (!isInput) {
                const courtVideoEl = document.getElementById('courtVideoPlayer');

                // Check if we're in "combo mode" - waiting for landing zone after selecting from zone
                // In this mode, letter keys should go to combo processing, not special shortcuts
                const inComboMode = rallyInProgress && selectedFromZone && !selectedToZone;

                // Arrow keys - Trajectory selection (when waiting for landing zone)
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (rallyInProgress && selectedFromZone) {
                        setTrajectory(1);  // Upward
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (rallyInProgress && selectedFromZone) {
                        setTrajectory(-1);  // Downward
                    }
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (rallyInProgress && selectedFromZone) {
                        setTrajectory(0);  // Flat
                    }
                }
                // < > - Navigate between annotations
                else if (e.key === '<' || e.key === ',') {
                    e.preventDefault();
                    jumpToCourtPrevAnnotation();
                } else if (e.key === '>' || e.key === '.') {
                    e.preventDefault();
                    jumpToCourtNextAnnotation();
                }
                // C/V - Jump 10 frames (disabled in combo mode - use 8/9 for frame nav during shots)
                else if ((e.key === 'c' || e.key === 'C') && !inComboMode) {
                    e.preventDefault();
                    navigateCourtFrames(-10);
                } else if ((e.key === 'v' || e.key === 'V') && !inComboMode) {
                    e.preventDefault();
                    navigateCourtFrames(10);
                }
                // B - Toggle Zone 6/4 backhand mode (disabled in combo mode - toggle before clicking from zone)
                else if ((e.key === 'b' || e.key === 'B') && !inComboMode) {
                    e.preventDefault();
                    // Toggle backhand mode (works when rally is in progress but before selecting from zone)
                    zone6Mode = (zone6Mode === 'overhead') ? 'backhand' : 'overhead';
                    updateModeIndicators();
                    console.log('Zone 6 mode:', zone6Mode);
                }
                // D - Dribble toggle (disabled in combo mode - use 'fdb'/'bdb' combos for dribble shots)
                else if ((e.key === 'd' || e.key === 'D') && !inComboMode) {
                    e.preventDefault();
                    // Toggle dribble mode (works when not in combo mode)
                    dribbleMode = !dribbleMode;
                    updateModeIndicators();
                    console.log('Dribble mode:', dribbleMode);
                }
                // U - Undo last rally winner (disabled in combo mode)
                else if ((e.key === 'u' || e.key === 'U') && !waitingForServer && !inComboMode) {
                    e.preventDefault();
                    undoLastRallyWinner();
                }
                // 8 - Single frame backward
                else if (e.key === '8' && !waitingForServer) {
                    e.preventDefault();
                    navigateCourtFrames(-1);
                }
                // 9 - Single frame forward
                else if (e.key === '9' && !waitingForServer) {
                    e.preventDefault();
                    navigateCourtFrames(1);
                }
                // 0 - Jump 400 frames
                else if (e.key === '0' && !waitingForServer) {
                    e.preventDefault();
                    navigateCourtFrames(400);
                }
                // Spacebar - Play/pause
                else if (e.key === ' ') {
                    e.preventDefault();
                    // Play/pause court video - use readyState >= 1 for faster response
                    // readyState 1 = HAVE_METADATA (enough to start playing)
                    if (courtVideoEl && courtVideoEl.readyState >= 1) {
                        if (courtVideoEl.paused) {
                            courtVideoEl.play().catch(err => {
                                console.log('Court video play prevented:', err.message);
                            });
                        } else {
                            courtVideoEl.pause();
                        }
                    }
                }
                // Letter keys - shot type combo override (e.g., 'fd' for forehand drop)
                // Only processed when from zone is selected and waiting for to zone
                else if (/^[a-zA-Z]$/.test(e.key) && !isInput) {
                    if (processCourtComboKey(e.key)) {
                        e.preventDefault();
                    }
                }
            }
        });
        
        // Jump to previous court annotation
        function jumpToCourtPrevAnnotation() {
            const courtVideoEl = document.getElementById('courtVideoPlayer');
            if (!courtVideoEl || courtAnnotations.length === 0) return;
            
            const currentTime = courtVideoEl.currentTime;
            let target = null;
            
            for (let i = courtAnnotations.length - 1; i >= 0; i--) {
                if (courtAnnotations[i].timestamp < currentTime - 0.05) {
                    target = courtAnnotations[i];
                    break;
                }
            }
            
            if (target) {
                courtVideoEl.currentTime = target.timestamp;
                courtVideoEl.pause();
                updateCourtFrameInfo();
            }
        }
        
        // Jump to next court annotation
        function jumpToCourtNextAnnotation() {
            const courtVideoEl = document.getElementById('courtVideoPlayer');
            if (!courtVideoEl || courtAnnotations.length === 0) return;
            
            const currentTime = courtVideoEl.currentTime;
            let target = null;
            
            for (let i = 0; i < courtAnnotations.length; i++) {
                if (courtAnnotations[i].timestamp > currentTime + 0.05) {
                    target = courtAnnotations[i];
                    break;
                }
            }
            
            if (target) {
                courtVideoEl.currentTime = target.timestamp;
                courtVideoEl.pause();
                updateCourtFrameInfo();
            }
        }
        
        // Court Combo Override Functions
        // Mapping of short combos to shot types (using same combos as tagging mode)
        const courtComboMap = new Map([
            // Forehand shots
            ['fs', 'forehand_smash'],
            ['fc', 'forehand_clear'],
            ['fdr', 'forehand_drive'],
            ['fd', 'forehand_drop'],
            ['fdf', 'forehand_defense'],
            ['fpd', 'forehand_pulldrop'],
            ['fnk', 'forehand_netkeep'],
            ['fdb', 'forehand_dribble'],
            ['fp', 'forehand_push'],
            ['fnt', 'forehand_nettap'],
            ['fl', 'forehand_lift'],
            ['fb', 'forehand_block'],
            ['ffg', 'forehand_flatgame'],
            // Backhand shots
            ['bs', 'backhand_smash'],
            ['bc', 'backhand_clear'],
            ['bdr', 'backhand_drive'],
            ['bd', 'backhand_drop'],
            ['bdf', 'backhand_defense'],
            ['bpd', 'backhand_pulldrop'],
            ['bnk', 'backhand_netkeep'],
            ['bdb', 'backhand_dribble'],
            ['bp', 'backhand_push'],
            ['bnt', 'backhand_nettap'],
            ['bl', 'backhand_lift'],
            ['bb', 'backhand_block'],
            ['bfg', 'backhand_flatgame'],
            // Overhead shots
            ['os', 'overhead_smash'],
            ['oc', 'overhead_clear'],
            ['od', 'overhead_drop'],
            ['ohs', 'overhead_halfsmash'],
        ]);

        // Build prefix set for partial matching
        const courtComboPrefixes = new Set();
        for (const combo of courtComboMap.keys()) {
            for (let i = 1; i < combo.length; i++) {
                courtComboPrefixes.add(combo.substring(0, i));
            }
        }

        function processCourtComboKey(key) {
            // Only process when we have a from zone selected but no to zone yet
            if (!selectedFromZone || selectedToZone) return false;
            if (!rallyInProgress) return false;

            const char = key.toLowerCase();
            // Only accept letters
            if (!/^[a-z]$/.test(char)) return false;

            // Clear any pending timeout
            if (courtComboTimeout) {
                clearTimeout(courtComboTimeout);
            }

            // Add to buffer
            courtComboBuffer += char;

            // Check for exact match
            if (courtComboMap.has(courtComboBuffer)) {
                const shotType = courtComboMap.get(courtComboBuffer);
                overriddenShotType = shotType;
                showCourtComboIndicator(courtComboBuffer, shotType, 'matched');

                // Auto-clear after 2 seconds if user doesn't click
                courtComboTimeout = setTimeout(() => {
                    // Don't clear if they haven't selected a zone yet
                }, 2000);

                console.log('Shot override set:', shotType);
                return true;
            }

            // Check for prefix match (typing in progress)
            if (courtComboPrefixes.has(courtComboBuffer)) {
                showCourtComboIndicator(courtComboBuffer, null, 'pending');

                // Auto-clear after 1.5 seconds of no input
                courtComboTimeout = setTimeout(() => {
                    courtComboBuffer = '';
                    overriddenShotType = null;
                    hideCourtComboIndicator();
                }, 1500);

                return true;
            }

            // No match - show error briefly then clear
            showCourtComboIndicator(courtComboBuffer, null, 'error');
            courtComboTimeout = setTimeout(() => {
                courtComboBuffer = '';
                overriddenShotType = null;
                hideCourtComboIndicator();
            }, 500);

            return true;
        }

        function showCourtComboIndicator(combo, shotType, status) {
            const indicator = document.getElementById('courtComboIndicator');
            if (!indicator) return;

            const keysEl = indicator.querySelector('.combo-keys');
            const shotEl = indicator.querySelector('.combo-shot');

            keysEl.textContent = combo.toUpperCase();
            shotEl.textContent = shotType ? formatShotName(shotType) : (status === 'pending' ? 'typing...' : 'invalid');

            indicator.className = 'court-combo-indicator visible ' + status;
        }

        function hideCourtComboIndicator() {
            const indicator = document.getElementById('courtComboIndicator');
            if (indicator) {
                indicator.classList.remove('visible');
            }
        }

        // Navigate frames for court video
        function navigateCourtFrames(delta) {
            const courtVideoEl = document.getElementById('courtVideoPlayer');
            if (courtVideoEl && courtVideoEl.readyState >= 2) {
                const currentTime = courtVideoEl.currentTime;
                const frameTime = delta * courtFrameRate;
                const newTime = Math.max(0, Math.min(courtVideoEl.duration, currentTime + frameTime));
                courtVideoEl.currentTime = newTime;
                updateCourtFrameInfo();
            }
        }
    </script>

    <!-- Court Calibration Integration (connects to Python backend) -->
    <script src="court-calibration/static/court-calibration-integration.js"></script>
</body>
</html>

